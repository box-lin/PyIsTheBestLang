# 【儿须成名酒须醉】Python3+马拉车算法+动态规划
***    
## 方法一：Python3+马拉车算法+动态规划
### 提交结果
- 执行用时： 204 ms , 在所有 Python3 提交中击败了 98.70% 的用户
- 内存消耗： 20.9 MB , 在所有 Python3 提交中击败了 83.35% 的用户
- 通过测试用例： 36 / 36

### 解题思路
1. 使用马拉车算法计算得到字符串的所有回文子串
2. 使用动态规划更新可以将字符串分割成回文串的最小段数

### 性能优化

- 无

### 复杂度分析

- 设字符串的长度为$n$，则有
    - 时间复杂度：$O(n^2)$
    - 空间复杂度：$O(n^2)$

### 代码
```python3
def manacher(s):
    # 马拉车算法
    n = len(s)
    arm = [0] * n
    l, r = 0, -1
    for i in range(0, n):
        k = 1 if i > r else min(arm[l + r - i], r - i + 1)

        # 持续增加回文串的长度
        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
            k += 1
        arm[i] = k

        # 更新右侧最远的回文串边界
        k -= 1
        if i + k > r:
            l = i - k
            r = i + k
    # 返回每个位置往右的臂长
    return arm


class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        t = "#" + "#".join(list(s)) + "#"
        dp = manacher(t)
        m = len(t)

        lst = []
        i = 0
        for j, w in enumerate(t):
            if w != "#":
                lst.append(i)
                i += 1
            else:
                lst.append(-1)

        ref = [[] for _ in range(n)]
        for j in range(m):
            left = j - dp[j] + 1
            right = j + dp[j] - 1
            while left <= right:
                if lst[left] != -1:
                    ref[lst[right]].append(lst[left])
                left += 1
                right -= 1

        dp = [n + 1] * (n + 1)
        dp[0] = 0
        for i in range(n):
            for j in ref[i]:
                if dp[j] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[j] + 1
        return dp[-1] - 1
```

***
## 方法二：Python3+两个动态规划
### 提交结果
- 执行用时： 532 ms , 在所有 Python3 提交中击败了 95.24% 的用户
- 内存消耗： 42.8 MB , 在所有 Python3 提交中击败了 30.06% 的用户
- 通过测试用例： 36 / 36
### 解题思路

1. 使用一个动态规划预处理得到字符串所有子串是否为回文串的信息
2. 再使用一个动态规划计算可以将字符串分割成最少回文子串段数


### 性能优化

- 无

### 复杂度分析

- 设字符串的长度为$n$，则有
  - 时间复杂度：$O(n^2)$
  - 空间复杂度：$O(n^2)$


### 代码
```python3
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = True
            if i + 1 < n and s[i] == s[i + 1]:
                dp[i][i + 1] = True
            for j in range(i + 2, n):
                dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]

        ans = list(range(n + 1))
        ans[0] = 0
        for i in range(n):
            for j in range(i + 1):
                if dp[j][i] and ans[j] + 1 < ans[i + 1]:
                    ans[i + 1] = ans[j] + 1
        return ans[-1] - 1
```
***
## 方法三：Python3+二分查找+字符串哈希
### 提交结果
- 执行用时： 228 ms , 在所有 Python3 提交中击败了 98.85% 的用户
- 内存消耗： 15.3 MB , 在所有 Python3 提交中击败了 80.32% 的用户
- 通过测试用例： 57 / 57

### 解题思路

- 使用字符串哈希算法判断重复的子序列，同时使用二分查找确定最大长度
### 性能优化

- 无

### 复杂度分析

- 设数组的长度分别为$n$和$m$，则有
  - 时间复杂度：$O(m+n)log\min(m,n))$
  - 空间复杂度：$O(m+n)$

### 代码
```python3
import random


P1 = random.randint(100, 200)
P2 = random.randint(100, 200)
MOD1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
MOD2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

DP1 = [1]
for _ in range(1, 1000 + 1):
    DP1.append((DP1[-1] * P1) % MOD1)
DP2 = [1]
for _ in range(1, 1000 + 1):
    DP2.append((DP2[-1] * P2) % MOD2)


class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:

        def check(k):

            # 预先计算存储nums2的子序列哈希
            pre = set()
            hash1 = hash2 = 0
            for i in range(k):
                hash1 += DP1[k - 1 - i] * nums2[i]
                hash1 %= MOD1
                hash2 += DP2[k - 1 - i] * nums2[i]
                hash2 %= MOD2
            pre.add((hash1, hash2))
            for i in range(k, m):
                hash1 -= DP1[k - 1] * nums2[i - k]
                hash1 *= P1
                hash1 += DP1[0] * nums2[i]
                hash1 %= MOD1

                hash2 -= DP2[k - 1] * nums2[i - k]
                hash2 *= P2
                hash2 += DP2[0] * nums2[i]
                hash2 %= MOD2

                pre.add((hash1, hash2))

            # 判断nums1的子序列哈希
            hash1 = hash2 = 0
            for i in range(k):
                hash1 += DP1[k - 1 - i] * nums1[i]
                hash1 %= MOD1
                hash2 += DP2[k - 1 - i] * nums1[i]
                hash2 %= MOD2
            if (hash1, hash2) in pre:
                return True
            for i in range(k, n):
                hash1 -= DP1[k - 1] * nums1[i - k]
                hash1 *= P1
                hash1 += DP1[0] * nums1[i]
                hash1 %= MOD1

                hash2 -= DP2[k - 1] * nums1[i - k]
                hash2 *= P2
                hash2 += DP2[0] * nums1[i]
                hash2 %= MOD2

                if (hash1, hash2) in pre:
                    return True
            return False

        n = len(nums1)
        m = len(nums2)
        low = 0
        high = min(len(nums1), len(nums2))
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low
```


## 方法四：Python3+滑动窗口
### 提交结果
- 执行用时： 2696 ms , 在所有 Python3 提交中击败了 86.48% 的用户
- 内存消耗： 14.9 MB , 在所有 Python3 提交中击败了 99.21% 的用户
- 通过测试用例： 57 / 57

### 解题思路

- 固定一个数组，挪动另一个数组进行按个比较，确定最大公共连续子序列的长度

### 性能优化

- 无

### 复杂度分析

- 设数组的长度分别为$n$和$m$，则有
  - 时间复杂度：$O((m+n)*min(m,n))$
  - 空间复杂度：$O(m+n)$

### 代码
```python3
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:

        def check(start):
            cnt = 0
            res = 0
            for x in range(start, start + n):
                if nums1[x] == nums2[x - start]:
                    cnt += 1
                else:
                    if cnt > res:
                        res = cnt
                    cnt = 0
            if cnt > res:
                res = cnt
            return res

        if len(nums1) < len(nums2):
            nums1, nums2 = nums2, nums1

        n = len(nums2)
        nums1 = [-1] * n + nums1 + [-1] * n
        ans = 0
        m = len(nums1)
        for i in range(m - n + 1):
            cur = check(i)
            if cur > ans:
                ans = cur
        return ans
```
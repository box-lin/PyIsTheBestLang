
```Python3
# 点求最大值
from collections import defaultdict
from sortedcontainers import SortedDict

class SegmentTree:
    def __init__(self):
        self.skyline = defaultdict(int)
        self.lazy = defaultdict(int)
        return

    def push_down(self, i):
        if self.lazy[i]:
            self.skyline[2*i] = max(self.skyline[2*i], self.lazy[i])
            self.skyline[2*i+1] = max(self.skyline[2*i+1], self.lazy[i])

            self.lazy[2*i] = max(self.lazy[2*i], self.lazy[i])
            self.lazy[2*i+1] = max(self.lazy[2*i+1], self.lazy[i])

            self.lazy[i] = 0
        return

    def update(self, l, r, h, s, t, i):
        if l <= s and t<=r:
            self.skyline[i] = max(self.skyline[i], h)
            self.lazy[i] = max(self.lazy[i], h)
            return

        m = s+(t-s)//2
        self.push_down(i)
        if l<=m:
            self.update(l, r, h, s, m, 2*i)
        if r>m:
            self.update(l, r, h, m+1, t, 2*i+1)

        self.skyline[i] = max(self.skyline[2*i], self.skyline[2*i+1])
        return

    def query(self, l, r, s, t, i):
        if l <= s and t<=r:
            return self.skyline[i]

        m = s+(t-s)//2
        self.push_down(i)
        ans = 0
        if l<=m:
            ans = max(ans, self.query(l, r, s, m, 2*i))
        if r>m:
            ans = max(ans, self.query(l, r, m+1, t, 2*i+1))
        return ans


class Solution:
    @staticmethod
    def getSkyline(buildings: List[List[int]]) -> List[List[int]]:
        segment_tree = SegmentTree()
        ceil = 2**31
        nodes = SortedDict()
        for l, r, h in buildings:
            segment_tree.update(l+1, r, h, 1, ceil, 1)
            nodes[l+1] = 1
            nodes[r+1] = 1

        pre = 0
        ans = []
        for k in nodes:
            h = segment_tree.query(k, k, 1, ceil, 1)
            if h != pre:
                ans.append([k-1, h])
            pre = h
        return ans
```

```Python3
# 区间覆盖
from collections import defaultdict

class SegmentTree:
    def __init__(self):
        self.cover = defaultdict(lambda: 1)
        self.lazy = defaultdict(int)
        self.count = 0

    def push_down(self, i):
        if self.lazy[i]:
            self.cover[2*i] = self.lazy[i]
            self.cover[2*i+1] = self.lazy[i]

            self.lazy[2*i] = self.lazy[i]
            self.lazy[2*i+1] = self.lazy[i]

            self.lazy[i] = 0


    def update(self, l, r, s, t, val, i):
        if l<=s and t<=r:
            self.cover[i] = val
            self.lazy[i] = val
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l<=m:
            self.update(l, r, s, m, val, 2*i)
        if r>m:
            self.update(l, r, m+1, t, val, 2*i+1)
        if self.cover[2*i] == self.cover[2*i+1] and self.cover[2*i+1]:
            self.cover[i] = self.cover[2*i+1]
        else:
            self.cover[i] = 0
        return

    def query(self, l, r, s, t, i):
        
        if self.cover[i]:
            self.count += (self.cover[i] == 2)*(t-s+1)
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l <= m:
            self.query(l, r, s, m, 2*i)
        if r > m:
            self.query(l, r, m+1, t, 2*i+1)
        return 


class Solution:
    def getNumber(self, root: Optional[TreeNode], ops: List[List[int]]) -> int:

        def pre_order(node):
            if not node:
                return []
            return pre_order(node.left) + [node.val] + pre_order(node.right)

        values = pre_order(root)
        n = len(values)

        left_ind = dict()
        right_ind = dict()
        for i, value in enumerate(values):
            if value not in left_ind:
                left_ind[value] = i
            right_ind[value] = i

        low = 0
        high = n - 1
        segment = SegmentTree()
        for tp, x, y in ops:
            left = left_ind[x]
            right = right_ind[y]
            segment.update(left, right, low, high, tp+1, 1)
        segment.query(low, high, low, high, 1)
        return segment.count
```


```Python3
# 区间求和
from collections import defaultdict

class SegmentTree:
    def __init__(self):
        self.cover = defaultdict(int)
        self.lazy = defaultdict(int)
        self.count = 0

    def push_down(self, i):
        if self.lazy[i]:
            self.cover[2*i] = self.lazy[i]
            self.cover[2*i+1] = self.lazy[i]

            self.lazy[2*i] = self.lazy[i]
            self.lazy[2*i+1] = self.lazy[i]

            self.lazy[i] = 0

    def update(self, l, r, s, t, val, i):
        if l <= s and t <= r:
            self.cover[i] = val
            self.lazy[i] = val
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l<=m:
            self.update(l, r, s, m, val, 2*i)
        if r>m:
            self.update(l, r, m+1, t, val, 2*i+1)
        self.cover[i] = self.cover[2*i] + self.cover[2*i+1]
        return

    def query(self, l, r, s, t, i):
        if l<=s and t<=r:
            return self.cover[i]
        self.push_down(i)
        m = s+(t-s)//2
        ans = 0
        if l <= m:
            ans += self.query(l, r, s, m, 2*i)
        if r > m:
            ans += self.query(l, r, m+1, t, 2*i+1)
        return ans
```
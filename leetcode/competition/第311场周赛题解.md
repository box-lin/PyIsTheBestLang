# [【儿须成名酒须醉】第311场力扣周赛题解]
***
### 写在前面
- 昨晚第87场双周赛打得稀烂800名，T3看成异或卡大半个小时，T4不会做..
- 今天周赛重拳出击，刷新周赛个人PB第7...

[【儿须成名酒须醉】第311场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-311

***    
## [题目一: 最小偶倍数]

[题目一: 最小偶倍数]: https://leetcode.cn/contest/weekly-contest-311/problems/smallest-even-multiple/
### 解题思路
没啥说的，API是永远的神，这块真的基础不牢地动山摇，看大佬的Python3感觉自己没学好，其实很多自带的函数很好使，比如快速幂pow之类的...
- 数学
- 最小公倍数
### 代码
```python3
class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return math.lcm(2, n)
```

### 复杂度分析
设整数为$n$，则有
- 时间复杂度$O(logn)$
- 空间复杂度$O(1)$

### 题目感想
其实这题目判断奇偶数也可以...偶数就是自己，奇数乘2，唉每次都是无脑做，同样的时间做完，完全被大佬的思路吊打...

***
## [题目二：最长的字母序连续子字符串的长度]

[题目二：最长的字母序连续子字符串的长度]: https://leetcode.cn/contest/weekly-contest-311/problems/length-of-the-longest-alphabetical-continuous-substring/
### 解题思路
经典遍历的写法，两个变量一个记录上一个位置的ASCII码，一个记录持续的长度
- 遍历
- 计数
### 代码
```python3
class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        ans = 0
        pre = ord(s[0])
        cnt = 1
        for w in s[1:]:
            if ord(w) == pre+1:
                cnt += 1
            else:
                ans = ans if ans > cnt else cnt
                cnt = 1
            pre = ord(w)
        ans = ans if ans > cnt else cnt
        return ans
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$
### 题目感想
喜欢这种一眼题，还有经典的写法，毕竟简单又擅长...
***
## [题目三：反转二叉树的奇数层]

[题目三：反转二叉树的奇数层]: https://leetcode.cn/contest/weekly-contest-311/problems/reverse-odd-levels-of-binary-tree/
### 解题思路
看着二叉树的规模，和完美的特性，那还是就又无脑暴力吧...
- 模拟
- 完美二叉树
- 层序遍历
### 代码
```python3
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        
        # 新建二叉树
        ans = TreeNode(root.val)
        # 记录上层父节点
        father = [ans]
        # 层序遍历
        stack = [root]
        order = 1 # 区分奇数层与偶数层
        while stack:
            nex = []
            value = []
            for node in stack:
                if node.left:
                    nex.append(node.left)
                    value.append(node.left.val)
                if node.right:
                    nex.append(node.right)
                    value.append(node.right.val)
            # 奇数层反转
            if order == 1:
                value = value[::-1]
            # 奇偶性变化
            order = 1 - order
            son = []
            if value:  # 有值进行新层的建立
                i = 0
                for node in father:
                    node.left = TreeNode(value[i])
                    i += 1
                    node.right = TreeNode(value[i])
                    i += 1
                    son.append(node.left)
                    son.append(node.right)
            # 更新原始树的下一层和新树的父节点层
            father = son[:]
            stack = nex[:]
        return ans
```
### 复杂度分析
设二叉树节点个数为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
### 题目感想
没想到其他优雅的解法，水平有限...
***
## [题目四：字符串的前缀分数和]

[题目四：字符串的前缀分数和]: https://leetcode.cn/contest/weekly-contest-311/problems/sum-of-prefix-scores-of-strings/
### 解题思路
也是经典写法，字典树计数板子题，看这个数据量，按照以往题目的经验感觉暴力也能过...
- 计数
- 字典树
- 暴力

### 字典树
```python3
class Trie:
    def __init__(self):
        self.dct = dict()
        return

    def update(self, word):
        cur = self.dct
        for w in word:
            if w not in cur:
                cur[w] = dict()
            cur = cur[w]
            cur["cnt"] = cur.get("cnt", 0) + 1
        return

    def query(self, word):
        cur = self.dct
        res = 0
        for w in word:
            if w not in cur:
                return False
            cur = cur[w]
            res += cur["cnt"]
        return res
    
    
class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        trie = Trie()
        for word in words:
            trie.update(word)
        return [trie.query(word) for word in words]
```
### 暴力（也能过）
```python3
class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        count = defaultdict(int)
        for word in words:
            m = len(word)
            for i in range(1, m + 1):
                count[word[:i]] += 1

        ans = []
        for word in words:
            m = len(word)
            cur = 0
            for i in range(1, m + 1):
                cur += count[word[:i]]
            ans.append(cur)
        return ans
```
### 复杂度分析
设单词数为$m$，平均单词长度为$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$

### 题目感想
暴力空间复杂度应该会更高的，取决于不同前缀的个数，可能是测试数据太弱，昨晚双周赛T3怎么就想着用字典树算异或呢明明是位或...
***
### 写在最后
谢谢阅读，周末愉快，休息一下吧...

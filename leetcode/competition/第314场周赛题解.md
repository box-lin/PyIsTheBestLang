# [【儿须成名酒须醉】第314场力扣周赛题解]
***

### 写在前面
又是T3坐牢的一天，分数疯狂减减！

[【儿须成名酒须醉】第314场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-314/
***    
## [题目一: 处理用时最长的那个任务的员工]


[题目一: 处理用时最长的那个任务的员工]: https://leetcode.cn/contest/weekly-contest-314/problems/the-employee-that-worked-on-the-longest-task/
### 解题思路
读懂题意，遍历取最大值即可。
- 遍历
### 代码
```python3
class Solution:
    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
        cost = -1
        ans = n + 1
        pre = 0
        for i, tm in logs:
            if tm - pre > cost or (tm - pre == cost and i < ans):
                ans = i
                cost = tm - pre
            pre = tm
        return ans
```


### 复杂度分析
设数组长度为n，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$
***
## [题目二：找出前缀异或的原始数组]

[题目二：找出前缀异或的原始数组]: https://leetcode.cn/contest/weekly-contest-314/problems/find-the-original-array-of-prefix-xor/
### 解题思路
根据前缀异或可得，相邻值的异或极为原始数组的值。
- 位运算
- 前缀和

### 代码
```python3
class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        n = len(pref)
        ans = [pref[0]]
        for i in range(1, n):
            ans.append(pref[i - 1] ^ pref[i])
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：使用机器人打印字典序最小的字符串]

[题目三：使用机器人打印字典序最小的字符串]: https://leetcode.cn/contest/weekly-contest-314/problems/using-a-robot-to-print-the-lexicographically-smallest-string/
### 解题思路
遍历数组，优先将当前字典序小的加入最终结果。
- 动态规划
- 单调栈

### 代码
```python3
class Solution:
    def robotWithString(self, s: str) -> str:
        n = len(s)
        
        # 动态规划记录右侧的最小字母
        right = ["z"] * (n + 1)
        for i in range(n - 1, -1, -1):
            right[i] = min(right[i + 1], s[i])
        
        ans = ""
        stack = []
        for i in range(n):
            stack.append(s[i])
            # 假如当前栈顶为最小字母则出栈加到最终结果
            while stack and stack[-1] <= right[i + 1]:
                ans += stack.pop()
        return ans + "".join(stack[::-1])
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目四：矩阵中和能被 K 整除的路径]

[题目四：矩阵中和能被 K 整除的路径]: https://leetcode.cn/contest/weekly-contest-314/problems/paths-in-matrix-whose-sum-is-divisible-by-k/
### 解题思路
使用动态规划寻找模k的路径数目即可，采用记忆化深搜简写。
- 记忆化搜索
- 动态规划

### 代码
```python3
MOD = 10 ** 9 + 7


class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])

        @lru_cache(None)
        def dfs(i, j):
            cnt = [0] * k
            num = grid[i][j]
            # 搜索中止条件
            if i == m - 1 and j == n - 1:
                cnt[num % k] = 1
                return cnt
            for x, y in [[i + 1, j], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n:
                    nex = dfs(x, y)
                    # 加上当前值后更新模余的数量
                    for i in range(k):
                        cnt[(i + num) % k] += nex[i]
            for i in range(k):
                cnt[i] %= MOD
            return cnt

        return dfs(0, 0)[0]
```
### 复杂度分析
设矩阵长为$m$，宽为$n$，需要整除的数为$k$，则有
- 时间复杂度$O(mnk)$
- 空间复杂度$O(mnk)$

***
### 写在最后
谢谢阅读，继续努力！
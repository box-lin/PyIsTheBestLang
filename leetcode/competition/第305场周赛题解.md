# 【儿须成名酒须醉】力扣[第305场周赛]题解
***    
## [题目一]：暴力

```python3
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        n = len(nums)
        ans= 0
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    if nums[j]-nums[i]==nums[k]-nums[j]==diff:
                        ans += 1
        return ans
```

***
## [题目二]：深度优先搜索

```python3
from collections import defaultdict


class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        dct = defaultdict(list)
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)

        ans = 0
        visit = [0]*n
        for i in restricted:
            visit[i] = 1

        def dfs(root):
            nonlocal ans
            ans += 1
            visit[root] = 1
            for nex in dct[root]:
                if not visit[nex]:
                    dfs(nex)
            return
        dfs(0)
        return ans
```
***
## [题目三]：动态规划

```python3
class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n==2:
            return nums[0]==nums[1]
        
        dp = [False]*(n+1)
        dp[0]= True
        dp[2] = nums[0]==nums[1]
        dp[3] = (nums[0]==nums[1]==nums[2]) | (nums[0]+1==nums[1]==nums[2]-1)
        for i in range(3, n):
            dp[i+1] = dp[i+1] or (dp[i-1] and nums[i-1]==nums[i])
            dp[i+1] = dp[i+1] or (dp[i-2] and nums[i-1]==nums[i]==nums[i-2])
            dp[i+1] = dp[i+1] or (dp[i-2] and nums[i-2]+1==nums[i-1]==nums[i]-1)
        return dp[-1]
```
***
## [题目四]：动态规划

```python3
class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        lst = [ord(va)-ord('a') for va in s]
        n = len(lst)

        pre = [0]*26
        pre[lst[0]] = 1
        for i in range(1, n):
            cur = pre[:]
            for j in range(26):
                if abs(j-lst[i]) <= k and pre[j] + 1 > cur[lst[i]]:
                    cur[lst[i]] = pre[j] + 1
            if cur[lst[i]] == 0:
                cur[lst[i]] = 1
            pre = cur[:]
        return max(pre)
```


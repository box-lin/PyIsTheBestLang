# 【儿须成名酒须醉】力扣[第304场周赛]题解
***    
## [题目一]：广度优先搜索
### 提交结果
- 执行用时： 252 ms , 在所有 Python3 提交中击败了 88.89% 的用户
- 内存消耗： 19.6 MB , 在所有 Python3 提交中击败了 42.48% 的用户

### 解题思路

- 层序遍历，并记录比较层序和更新结果

### 性能优化

- 遍历层序的同时记录层序和，省去使用$sum$函数

### 复杂度分析

- 设节点个数为$n$，则有
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(n)$

### 代码
```python3
class Solution:
  def maxLevelSum(self, root: Optional[TreeNode]) -> int:
    stack = [root]
    pre = root.val
    ans = 1
    level = 1
    while stack:
      cur = 0
      nex = []
      for node in stack:
        cur += node.val
        if node.left:
          nex.append(node.left)
        if node.right:
          nex.append(node.right)
      if cur > pre:
        pre = cur
        ans = level
      stack = nex
      level += 1
    return ans
```

***
## [题目二]：广度优先搜索
### 提交结果
- 执行用时： 272 ms , 在所有 Python3 提交中击败了 56.86% 的用户
- 内存消耗： 19.6 MB , 在所有 Python3 提交中击败了 66.01% 的用户

### 解题思路

- 深度优先搜索，使用哈希维护层序和，最后比较得出最终结果

### 性能优化

- 只使用一个哈希存储层序和

### 复杂度分析

- 设节点个数为$n$，则有
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(n)$

### 代码
```python3
from collections import defaultdict


class Solution:
  def maxLevelSum(self, root: Optional[TreeNode]) -> int:

    cnt = defaultdict(int)

    def dfs(node, level):
      if not node:
        return
      cnt[level] += node.val
      dfs(node.left, level+1)
      dfs(node.right, level+1)
      return
    dfs(root, 1)

    ans = 1
    for k in cnt:
      if cnt[k] > cnt[ans]:
        ans = k
    return ans
```
***
## [题目三]：广度优先搜索

### 提交结果
- 执行用时： 712 ms , 在所有 Python3 提交中击败了 83.82% 的用户
- 内存消耗： 38.7 MB , 在所有 Python3 提交中击败了 27.94% 的用户

### 解题思路

1. 首先同方法一方法二进行索引映射遍历数组，不同的是方法一方法二通过类似动态维护前缀和来获取结果
2. 这里使用枚举的办法，将当前值作为三元升序组的中间值，维护前序有序集合通过二分查找可以知道小当前值的个数
3. 设小于当前值$num$也就是可以作为三元组第一个数的有$small$个，则其左边比$num$大的值有$i-small$个，而比$num$大的
   数总共有$n-1-num$，因此三元组的最后一个数可以有$n-1-num-(i-small)$
4. 则以当前值为中间值的三元组个数为$small * (n - 1 - num - (i-small))$

### 性能优化

- 同方法一

### 复杂度分析

- 设数组长度为$n$，则有
    - 时间复杂度：$O(nlogn)$
    - 空间复杂度：$O(n)$

### 代码
```python3
from sortedcontainers import SortedList


class Solution:
  def goodTriplets(self, nums1, nums2) -> int:
    dct = {num: i for i, num in enumerate(nums1)}
    nums2 = [dct[num] for num in nums2]
    n = len(nums2)

    ans = 0
    pre = SortedList()
    for i, num in enumerate(nums2):
      small = pre.bisect_left(num)
      ans += small * (n - 1 - num - (i-small))
      pre.add(num)
    return ans
```
***
## [题目四]：广度优先搜索

### 提交结果
- 执行用时： 712 ms , 在所有 Python3 提交中击败了 83.82% 的用户
- 内存消耗： 38.7 MB , 在所有 Python3 提交中击败了 27.94% 的用户

### 解题思路

1. 首先同方法一方法二进行索引映射遍历数组，不同的是方法一方法二通过类似动态维护前缀和来获取结果
2. 这里使用枚举的办法，将当前值作为三元升序组的中间值，维护前序有序集合通过二分查找可以知道小当前值的个数
3. 设小于当前值$num$也就是可以作为三元组第一个数的有$small$个，则其左边比$num$大的值有$i-small$个，而比$num$大的
   数总共有$n-1-num$，因此三元组的最后一个数可以有$n-1-num-(i-small)$
4. 则以当前值为中间值的三元组个数为$small * (n - 1 - num - (i-small))$

### 性能优化

- 同方法一

### 复杂度分析

- 设数组长度为$n$，则有
    - 时间复杂度：$O(nlogn)$
    - 空间复杂度：$O(n)$

### 代码
```python3
from sortedcontainers import SortedList


class Solution:
  def goodTriplets(self, nums1, nums2) -> int:
    dct = {num: i for i, num in enumerate(nums1)}
    nums2 = [dct[num] for num in nums2]
    n = len(nums2)

    ans = 0
    pre = SortedList()
    for i, num in enumerate(nums2):
      small = pre.bisect_left(num)
      ans += small * (n - 1 - num - (i-small))
      pre.add(num)
    return ans
```


[题目一]: https://www.latexlive.com/home
[题目二]: https://www.latexlive.com/home
[题目三]: https://www.latexlive.com/home
[题目四]: https://www.latexlive.com/home
[第304场周赛]: https
# [【儿须成名酒须醉】第88场力扣夜喵双周赛题解]
***

### 写在前面
这些题目基本都是有原题的类型，感觉周赛一次难一次简单，预言一波明天会比较难！
![image.png](https://pic.leetcode-cn.com/1664638841-vAGAEz-image.png)

[【儿须成名酒须醉】第88场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-88/
***    
## [题目一: 删除字符使频率相同]


[题目一: 删除字符使频率相同]: https://leetcode.cn/contest/biweekly-contest-88/problems/remove-letter-to-equalize-frequency/
### 解题思路
最麻烦最容易WA的题目，算上时间难度系数不低的，想什么贪心，T1就是要暴力才对！
- 哈希
- 计数
- 暴力
### 代码
```python3
class Solution:
    def equalFrequency(self, word: str) -> bool:
        cnt = list(Counter(word).values())
        n = len(cnt)
        for i in range(n):
            tmp = cnt[:]
            tmp[i] -= 1
            if not tmp[i]:
                tmp.pop(i)
            if len(set(tmp)) == 1:
                return True
        return False
```
### 贪心
会让人错到发疯的贪心解法，这题有类似的hard[1224. 最大相等频率]题目。

[1224. 最大相等频率]: https://leetcode.cn/problems/maximum-equal-frequency/

```python3
class Solution:
    def equalFrequency(self, word: str) -> bool:
        cnt = Counter(list(Counter(word).values()))
        if len(cnt) == 1:
            if min(cnt) == 1:
                return True
            if cnt[min(cnt)] == 1:
                return True
        if len(cnt) == 2:
            if max(cnt) - min(cnt) == 1 and cnt[max(cnt)] == 1:
                return True
            if cnt[min(cnt)] == 1 and min(cnt) == 1:
                return True
        return False

```

### 复杂度分析
设字符串不同字母个数为$n$，则有
- 时间复杂度$O(n^2)$
- 空间复杂度$O(n)$
***
## [题目二：最长上传前缀]

[题目二：最长上传前缀]: https://leetcode.cn/contest/biweekly-contest-88/problems/longest-uploaded-prefix/
### 解题思路
使用并查集和数组记录更新已经上传视频的部分，关注video为1的连通子集情况，将根优先置为序号较大的video即可得到跟1相关联的最大前缀。
- 并查集
- 数组
### 代码
```python3
class UnionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1] * n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        if root_x >= root_y:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return True

    
class LUPrefix:

    def __init__(self, n: int):
        self.uf = UnionFind(n)
        self.visit = [0]*n

    def upload(self, video: int) -> None:
        video -= 1
        self.visit[video] = 1
        for x in [video-1, video+1]:
            if 0 <= x < len(self.visit) and self.visit[x]:
                self.uf.union(x, video)
        return 
                
    def longest(self) -> int:
        if not self.visit[0]:
            return 0
        return self.uf.find(0) + 1
```
### 复杂度分析
设视频个数为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
### 另解
考虑到有序的性质，也可以使用有序集合二分查找进行维护。
- 有序集合
- 二分查找
```python3
from sortedcontainers import SortedList


class LUPrefix:

    def __init__(self, n: int):
        self.lst = SortedList()
        self.n = n

    def upload(self, video: int) -> None:
        self.lst.add(video)
        return

    def longest(self) -> int:
        
        if not self.lst or self.lst[0] != 1:
            return 0

        i = 0
        j = len(self.lst) - 1
        while i < j - 1:
            mid = i + (j - i) // 2
            if self.lst[mid] == mid + 1:
                i = mid
            else:
                j = mid

        return j + 1 if self.lst[j] == j + 1 else i + 1



### 优化
参考妙蛙种子的题解，使用哈希和一个指针维护观看情况。
- 哈希
- 指针

```python3
class LUPrefix:
    def __init__(self):
        self.visit = set()
        self.ind = 0

    def upload(self, video: int) -> None:
        self.visit.add(video)
        return

    def longest(self) -> int:
        while self.ind + 1 in self.visit:
            self.ind += 1
        return self.ind
```
***
## [题目三：所有数对的异或和]

[题目三：所有数对的异或和]: https://leetcode.cn/contest/biweekly-contest-88/problems/bitwise-xor-of-all-pairings/
### 解题思路
每个数组的数字都会和另外一个数组的所有数字做异或，最后再用所有的数对和继续做异或，设nums1和nums2的个数分别为m和n，最后结果
等同于每个nums1的数字参与异或n次，每个nums2的数字参与异或m次，因此记录每个数字二进制位1参与异或的数字，最后模2即可得
到最终结果该二进制数位的值。
- 位运算
- 脑筋急转弯
### 代码
```python3
ind = {1<<i: i for i in range(33)}
    
    
class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        cnt = [0]*33
        for num in nums1:
            while num:
                cur = ind[num & (-num)]
                cnt[cur] += n
                num &= (num-1)
        
        for num in nums2:
            while num:
                cur = ind[num & (-num)]
                cnt[cur] += m
                num &= (num-1)
       
        ans = 0
        for i in range(33):
            if cnt[i] % 2:
                ans |= 1 << i
        return ans
```
### 复杂度分析
设数组的长度分别为$m$和$n$，二进制位数为$C$，则有
- 时间复杂度$O((m+n)C)$
- 空间复杂度$O(C)$

### 优化
考虑到最终异或的次数，可以直接根据m和n的奇偶性质直接进行对应的异或即可。
- 位运算
- 脑筋急转弯
```python3
class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        ans = 0
        if n % 2:
            for num in nums1:
                ans ^= num
        if m % 2:
            for num in nums2:
                ans ^= num
        return ans
```
***
## [题目四：满足不等式的数对数目]

[题目四：满足不等式的数对数目]: https://leetcode.cn/contest/biweekly-contest-88/problems/number-of-pairs-satisfying-inequality/
### 解题思路
经典的公式变换题目
$$nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff$$
等价于
$$nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff$$
要求是$i<j$，因此倒序遍历使用有序集合维护$nums1[j] - nums2[j] + diff$使用二分查找即可。

- 有序集合
- 二分查找
- 脑筋急转弯
### 代码
```python3
from sortedcontainers import SortedList


class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        n = len(nums1)
        ans = 0
        lst = SortedList([nums1[n - 1] - nums2[n - 1] + diff])
        for i in range(n - 2, -1, -1):
            k = lst.bisect_left(nums1[i] - nums2[i])
            ans += len(lst) - k
            lst.add(nums1[i] - nums2[i] + diff)
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***
### 写在最后
谢谢阅读，国庆快乐！
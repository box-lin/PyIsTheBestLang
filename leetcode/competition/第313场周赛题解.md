# [【儿须成名酒须醉】第313场力扣周赛题解]
***

### 写在前面
T3位运算、异或和贪心，这buff有点顶不住！好在久违的周赛双周赛AK，应该能上2500了！
![image.png](https://pic.leetcode-cn.com/1664683116-MrgXpY-image.png)

[【儿须成名酒须醉】第313场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-313/
***    
## [题目一: 公因子的数目]


[题目一: 公因子的数目]: https://leetcode.cn/contest/weekly-contest-313/problems/number-of-common-factors/
### 解题思路
数据范围有限，可以直接暴力枚举因子，也可以利用最大公约数的整数因子个数方式求解。
- 数学
- 素数
### 代码
```python3
class Solution:
    def commonFactors(self, a: int, b: int) -> int:

        def get_all_factor(num):
            factor = set()
            for i in range(1, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    factor.add(i)
                    factor.add(num // i)
            return len(factor)

        return get_all_factor(math.gcd(a, b))
```

### 暴力
```python3
class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        ans = 0
        for i in range(1, min(a, b) + 1):
            if a % i == b % i == 0:
                ans += 1
        return ans
```

### 复杂度分析
设两个数的最小值为n，则有
- 时间复杂度$O(logn)+O(\sqrt{n})$
- 空间复杂度$O(\sqrt{n})$
***
## [题目二：沙漏的最大总和]

[题目二：沙漏的最大总和]: https://leetcode.cn/contest/weekly-contest-313/problems/maximum-sum-of-an-hourglass/
### 解题思路
使用指针暴力计算即可，注意行列号的边界。
- 暴力
### 代码
```python3
class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                cur = 0
                for a in [-1, 0, 1]:
                    for b in [-1, 0, 1]:
                        cur += grid[i + a][j + b]
                cur -= grid[i][j - 1] + grid[i][j + 1]
                ans = ans if ans > cur else cur
        return ans
```
### 复杂度分析
设矩阵的行数与列数分别为$m$和$n$，沙漏大小为$C$，则有
- 时间复杂度$O(mnC)$
- 空间复杂度$O(1)$

### 优化
可以使用动态规划记录区域和，将常数C减小。

***
## [题目三：最小 XOR]

[题目三：最小 XOR]: https://leetcode.cn/contest/weekly-contest-313/problems/minimize-xor/
### 解题思路
根据num2的置位数进行匹配，利用异或的特性贪心寻找最小的数。
- 位运算
- 贪心
### 代码
```python3
class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:

        # 将num1转换成01二进制数组，并计算num2的位数个数
        lst = [1 if num1 & 1 << j else 0 for j in range(32)]
        while lst[-1] == 0:
            lst.pop()
        n = len(lst)
        one = bin(num2).count("1")

        # 已有1的个数大于需要的1个数，从最低位开始移除多余的1
        if sum(lst) >= one:
            remove = sum(lst) - one
            for j in range(n):
                if lst[j] == 1 and remove:
                    lst[j] = 0
                    remove -= 1
        # 已有1的个数少于需要的1个数，从最低位开始额外增加1
        else:
            add = one - sum(lst)
            for j in range(n):
                if add and lst[j] == 0:
                    add -= 1
                    lst[j] = 1
            # 若还是不够继续增加1
            if add:
                lst.extend([1] * add)
        return sum(1 << j if lst[j] == 1 else 0 for j in range(len(lst)))
```
### 复杂度分析
设num1和num2的最大数为$n$，则有
- 时间复杂度$O(logn)$
- 空间复杂度$O(logn)$

***
## [题目四：对字母串可执行的最大删除数]

[题目四：对字母串可执行的最大删除数]: https://leetcode.cn/contest/weekly-contest-313/problems/maximum-deletions-on-a-string/
### 解题思路
使用动态规划寻找最大删除次数
- 区间DP
- 动态规划

设dp[i]表示s[i:]的最大删除次数，则转移方程为
$$dp[i]=\max(1, 1+\max^{s[i:j]=s[j:2j-i]}dp[j])$$

### 代码
```python3
class Solution:
    def deleteString(self, s: str) -> int:

        @lru_cache(None)
        def dfs(j):
            if j >= m:
                return 0
            res = 1
            n = m - j
            for i in range(1, n // 2 + 1):
                if s[j:j + i] == s[j + i:j + 2 * i]:
                    res = res if res > 1 + dfs(j + i) else 1 + dfs(j + i)
            return res

        m = len(s)
        return dfs(0)
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n^2)$
- 空间复杂度$O(n)$

事实上寻找$s[i:j]=s[j:2*j-i]$的过程，复杂度应该也有额外的$O(n)$的，Python3的语言特性好像使得字符串的切片比较速度比较快！

### 优化
可以使用哈希存储每个字母的索引范围，这样可以在搜寻的时候跳过一些区段
- 哈希
- 索引
```python3
class Solution:
    def deleteString(self, s: str) -> int:

        @lru_cache(None)
        def dfs(j):
            if j >= m:
                return 0
            res = 1
            n = m - j
            x = bisect.bisect_right(ind[s[j]], j)
            y = bisect.bisect_left(ind[s[j]], j + n // 2)
            for k in ind[s[j]][x: y + 1]:
                if s[j:k] == s[k:2 * k - j]:
                    res = res if res > 1 + dfs(k) else 1 + dfs(k)
            return res

        m = len(s)
        ind = defaultdict(list)
        for i in range(m):
            ind[s[i]].append(i)
        return dfs(0)
```
### 另解
更优的做法应该是枚举子字符串的长度？利用字符串哈希进行字符串长度相等的判断，不过我没调出来超时了。
- 字符串哈希
***
### 写在最后
谢谢阅读，国庆快乐！
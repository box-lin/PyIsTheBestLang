# 【儿须成名酒须醉】Python3+枚举+备忘录+数论+深度优先搜索+记忆化搜索+哈希+回溯
***
## 提交结果
- 执行用时： 752 ms , 在所有 Python3 提交中击败了 95.00% 的用户    
- 内存消耗： 105.8 MB , 在所有 Python3 提交中击败了 80.00% 的用户    

## 解题思路

1. 由题意知$1<=num[i]<=50$，要求时互质的祖先节点，因此可以事先枚举计算这个范围内的互质的数对备用
2. 使用深度优先往子节点搜索，同时使用哈希记录访问过的节点值和$dfs$序，即访问的深度，在搜索到当前节点时，查看其互质的数是否出现在前序
中，并比较出离得最近的那个作为其结果
3. 遍历完当前节点的所有子节点之后，使用回溯对当前节点的访问信息进行清除

## 性能优化

- 在可以使用列表存储数组相关信息的时候，尽量不使用字典，即事先确定好容器的大小，能比较省时间和空间

## 复杂度分析

- 设节点个数为$n$，数据范围内质数个数为$m$,则有
    - 时间复杂度：$O(nm)$
    - 空间复杂度：$O(n)$

## 代码
```python3
import math
from collections import defaultdict

prime_pair = [[] for _ in range(51)]
for x in range(1, 51):
    for y in range(x, 51):
        if math.gcd(x, y) == 1:
            prime_pair[x].append(y)
            prime_pair[y].append(x)


class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        # 记录拓扑关系
        n = len(nums)
        edge = [[] for _ in range(n)]
        for u, v in edges:
            edge[u].append(v)
            edge[v].append(u)

        def dfs(root, order):
            # 查找可能存在的最近的互质祖先
            ind = -1
            recent = -1
            for num in prime_pair[nums[root]]:
                if pre[num] and pre[num][-1][1] > recent:
                    ind, recent = pre[num][-1]
            ans[root] = ind
            # 将当前的节点信息加入到祖先序列
            pre[nums[root]].append([root, order])
            visit[root] = 1
            for son in edge[root]:
                if not visit[son]:
                    dfs(son, order+1)
            # 回溯将此时的节点信息清除
            pre[nums[root]].pop(-1)
            visit[root] = 0
            return

        # 哈希记录前序祖先的值与搜索深度序号
        pre = defaultdict(list)
        # 深度优先搜索
        visit = [0]*n
        visit[0] = 1
        ans = [-1]*n
        dfs(0, 0)
        return ans
```
## 【儿须成名酒须醉】Python3+动态规划+记忆化搜索
***
### 提交结果
- 执行用时： 40 ms , 在所有 Python3 提交中击败了 93.23% 的用户
- 内存消耗： 15.8 MB , 在所有 Python3 提交中击败了 38.99% 的用户
- 通过测试用例： 45 / 45

### 解题思路

- 状态转移方程$dp[i][j]+dungeon[i][j]>=min(dp[i][j+1], dp[i+1][j])$
### 性能优化

- 可以退化成一维的动态规划

### 复杂度分析
设地下城行数与列数分别为$m$和$n$，有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$


### 代码
```python3
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[float("-inf")] * n for _ in range(m)]

        dp[m - 1][n - 1] = 1 if 1 > 1 - dungeon[m - 1][n - 1] else 1 - dungeon[m - 1][n - 1]
        for i in range(m - 2, -1, -1):
            dp[i][n - 1] = 1 if 1 > dp[i + 1][n - 1] - dungeon[i][n - 1] else dp[i + 1][n - 1] - dungeon[i][n - 1]
        for j in range(n - 2, -1, -1):
            dp[m - 1][j] = 1 if 1 > dp[m - 1][j + 1] - dungeon[m - 1][j] else dp[m - 1][j + 1] - dungeon[m - 1][j]

        for i in range(m - 2, -1, -1):
            for j in range(n - 2, -1, -1):
                low = dp[i + 1][j] if dp[i + 1][j] < dp[i][j + 1] else dp[i][j + 1]
                dp[i][j] = 1 if 1 > low - dungeon[i][j] else low - dungeon[i][j]
        return dp[0][0]
```

***
### 记忆化搜索
```python3
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:

        @lru_cache(None)
        def dfs(i, j):
            if i == m - 1 and j == n - 1:
                return max(1, 1 - dungeon[i][j])

            nex = float("inf")
            if i + 1 < m:
                nex = min(nex, dfs(i + 1, j))
            if j + 1 < n:
                nex = min(nex, dfs(i, j + 1))

            return max(1, nex - dungeon[i][j])

        m, n = len(dungeon), len(dungeon[0])
        return dfs(0, 0)
```
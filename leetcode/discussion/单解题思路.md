# 【儿须成名酒须醉】Python3+动态规划
***
## 提交结果
- 执行用时： 268 ms , 在所有 Python3 提交中击败了 47.22% 的用户
- 内存消耗： 19.9 MB , 在所有 Python3 提交中击败了 29.17% 的用户
- 通过测试用例： 45 / 45
## 解题思路

1. 首先观察发现要满足题意，无论是对于行还是对于列，都必须满足行列组成的二进制数只能是两个，且两个数的位运算互补，且两个数的计数需要正好满足相差最多一个
2. 对于$xxyyyx$和来说要变成目标只能是$xyxyxy$或者$yxyxyx$，同时由于只有两个数，与目标位置的编辑距离数一定成对出现，是偶数
3. 比如$xxyyyx$与$xyxyxy$不同的位置为$1245$，只需要交换$4//2$两次，因此可以罗列$xyxyxy$与$yxyxyx$计算取较小值即可
## 性能优化

- 无

## 复杂度分析

- 设整数数组长度为$n$，则有
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(n)$
    
## 代码


```#python3
class Solution:
    def maxEqualFreq(self, nums: List[int]) -> int:
        ans = 0

        # 数字计数哈希
        dct = dict()
        # 数字计数的计数哈希
        cnt = dict()

        for i, num in enumerate(nums):
            if num in dct:
                cnt[dct[num]] -= 1
                if not cnt[dct[num]]:
                    del cnt[dct[num]]

            # 更新数字计数与数字计数的计数
            dct[num] = dct.get(num, 0) + 1
            cnt[dct[num]] = cnt.get(dct[num], 0) + 1

            # 数字计数的计数哈希键即出现次数，有一个值，可能条件A与B
            if len(cnt) == 1:
                x = min(cnt)
                if x == 1 or cnt[x] == 1:
                    ans = i+1
            
            # 数字计数的计数哈希键即出现次数，有两个值，可能条件C与D
            if len(cnt) == 2:
                x, y = min(cnt), max(cnt)
                if x == 1 and cnt[x] == 1:
                    ans = i+1
                if x+1 == y and cnt[y] == 1:
                    ans = i+1
        return ans
```
# 【儿须成名酒须醉】Python3+并查集+着色法+深度优先搜索
***    
## 方法一：并查集
### 提交结果     
- 执行用时： 64 ms , 在所有 Python3 提交中击败了 9.55% 的用户
- 内存消耗： 15.4 MB , 在所有 Python3 提交中击败了 58.23% 的用户
- 通过测试用例： 81 / 81

### 解题思路    


- 使用并查集遍历，将每个点相连接的点连通起来，同时查看他们和这个点是否在并查集相连


### 性能优化

- 无

### 复杂度分析

- 设人数为$n$，边连接关系数为$m$，则有
    - 时间复杂度：$O(n+m)$    
    - 空间复杂度：$O(n+m)$   

### 代码
```Python3
from collections import defaultdict


class UnionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1]*n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def get_root_part(self):
        # 获取每个根节点对应的组
        part = defaultdict(list)
        n = len(self.root)
        for i in range(n):
            part[self.find(i)].append(i)
        return part

    def get_root_size(self):
        # 获取每个根节点对应的组大小
        size = defaultdict(int)
        n = len(self.root)
        for i in range(n):
            size[self.find(i)] = self.size[self.find(i)]
        return size


class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        uf = UnionFind(n)
        for i in range(n):
            for j in graph[i]:
                uf.union(graph[i][0], j)
                if uf.is_connected(i, j):
                    return False
        return True
```

***
## 方法二：着色法+深度优先搜索
### 提交结果    

- 执行用时： 36 ms , 在所有 Python3 提交中击败了 93.48% 的用户
- 内存消耗： 15.6 MB , 在所有 Python3 提交中击败了 15.27% 的用户
- 通过测试用例： 81 / 81
### 解题思路    

1. 既然是二分则等价于每个连接对的节点可以使用不同颜色进行赋值，若再次访问发现冲突则不可能
2. 具体使用$-1$表示未访问，$0$表示红色，$1$表示蓝色，依次根据连接关系进行搜索

### 性能优化

- 无

### 复杂度分析


- 设人数为$n$，边连接关系数为$m$，则有
  - 时间复杂度：$O(n+m)$
  - 空间复杂度：$O(n+m)$

### 代码

```Python3
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        
        def dfs(k, c):
            nonlocal ans
            if not ans:
                return
            color[k] = c
            for x in graph[k]:
                if color[x] != -1:
                    if color[x] == c:
                        ans = False
                        return
                else:
                    dfs(x, 1-c)
            return

        color = [-1]*n
        ans = True
        for i in range(n):
            if color[i] == -1:
                dfs(i, 0)
        return ans
```
***
## 方法三：深度优先搜索
### 提交结果
- 执行用时： 116 ms , 在所有 Python3 提交中击败了 73.37% 的用户
- 内存消耗： 21 MB , 在所有 Python3 提交中击败了 8.29% 的用户
- 通过测试用例： 112 / 112

### 解题思路

1. 有点类似于树形DP的思想，一个点是安全的当且仅当它的所有子节点也是安全的
2. 因此采用深搜的方式进行查询记录是否安全，同时使用一个访问数组进行记录避免重复查询

### 性能优化

- 无

### 复杂度分析

- 设节点个数为$n$，平均出度为$m$，则有
  - 时间复杂度：$O(nm)$
  - 空间复杂度：$O(nm)$

### 代码
```Python3
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        is_safe = [0]*n
        visit = [0]*n

        def dfs(i):
            if visit[i]:
                return is_safe[i]
            visit[i] = 1
            if not graph[i]:
                is_safe[i] = 1
                return 1

            for k in graph[i]:
                if visit[k] and not is_safe[k]:
                    is_safe[i] = 0
                    return 0
                else:
                    if not dfs(k):
                        is_safe[i] = 0
                        return 0
            is_safe[i] = 1
            return 1

        for j in range(n):
            dfs(j)

        return [i for i in range(n) if is_safe[i]]
```
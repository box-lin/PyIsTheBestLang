# 【儿须成名酒须醉】Python3+深度优先搜索+回溯
***    
## 方法一：深度优先搜索
### 提交结果     
- 执行用时： 44 ms , 在所有 Python3 提交中击败了 29.66% 的用户
- 内存消耗： 15.2 MB , 在所有 Python3 提交中击败了 27.85% 的用户
- 通过测试用例： 26 / 26

### 解题思路    

- 遍历数组，依次选择前序没有出现过的数加入

### 性能优化

- 无

### 复杂度分析

- 设数组长度为$n$，则有
    - 时间复杂度：$O(n*n!)$    
    - 空间复杂度：$O(n)$   

### 代码
```#Python3
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:

        def dfs(pre):
            nonlocal ans
            if len(pre) == n:
                ans.append(pre)
                return 
            for i in range(n):
                if nums[i] not in pre:
                    dfs(pre+[nums[i]])
            return

        n = len(nums)
        ans = []
        dfs([])
        return ans
```

***
## 方法二：回溯
### 提交结果    
- 执行用时： 40 ms , 在所有 Python3 提交中击败了 59.77% 的用户
- 内存消耗： 15.2 MB , 在所有 Python3 提交中击败了 22.61% 的用户 
- 通过测试用例： 26 / 26

### 解题思路    

- 在方法一深度优先搜索的基础上，增加visit数组来判断数组在前序中是否存在

### 性能优化

- 无

### 复杂度分析


- 设数组长度为$n$，则有
  - 时间复杂度：$O(n*n!)$
  - 空间复杂度：$O(n)$

### 代码

```#Python3
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:

        def dfs(pre):
            nonlocal ans
            if len(pre) == n:
                ans.append(pre)
                return
            for i in range(n):
                if not visit[i]:
                    visit[i] = 1
                    dfs(pre+[nums[i]])
                    visit[i] = 0
            return

        n = len(nums)
        visit = [0]*n
        ans = []
        dfs([])
        return ans
```
***
## 方法三：深度优先搜索
### 提交结果
- 执行用时： 116 ms , 在所有 Python3 提交中击败了 73.37% 的用户
- 内存消耗： 21 MB , 在所有 Python3 提交中击败了 8.29% 的用户
- 通过测试用例： 112 / 112

### 解题思路

1. 有点类似于树形DP的思想，一个点是安全的当且仅当它的所有子节点也是安全的
2. 因此采用深搜的方式进行查询记录是否安全，同时使用一个访问数组进行记录避免重复查询

### 性能优化

- 无

### 复杂度分析

- 设节点个数为$n$，平均出度为$m$，则有
  - 时间复杂度：$O(nm)$
  - 空间复杂度：$O(nm)$

### 代码
```Python3
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        is_safe = [0]*n
        visit = [0]*n

        def dfs(i):
            if visit[i]:
                return is_safe[i]
            visit[i] = 1
            if not graph[i]:
                is_safe[i] = 1
                return 1

            for k in graph[i]:
                if visit[k] and not is_safe[k]:
                    is_safe[i] = 0
                    return 0
                else:
                    if not dfs(k):
                        is_safe[i] = 0
                        return 0
            is_safe[i] = 1
            return 1

        for j in range(n):
            dfs(j)

        return [i for i in range(n) if is_safe[i]]
```
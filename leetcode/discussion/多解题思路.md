# 【儿须成名酒须醉】Python3+背包DP+组合数学+隔板法
***    
## 方法一：Python3+背包DP
### 提交结果     
- 执行用时： 32 ms , 在所有 Python3 提交中击败了 94.66% 的用户
- 内存消耗： 15 MB , 在所有 Python3 提交中击败了 20.61% 的用户
- 通过测试用例： 41 / 41

### 解题思路    

- 动态规划

### 性能优化

- 无

### 复杂度分析

- 设目标字符串长度为$n$，则有
    - 时间复杂度：$O(n)$    
    - 空间复杂度：$O(n)$   

### 代码
```#Python3
dp = [[0] * 5 for _ in range(51)]
count = [0, 5]
pre = [1, 1, 1, 1, 1]
for i in range(2, 51):
    cur = [0] * 5
    add = 0
    for j in range(5):
        for k in range(j + 1):
            cur[j] += pre[k]
            add += pre[k]
    pre = cur
    count.append(add)


class Solution:
    def countVowelStrings(self, n: int) -> int:
        return count[n]
```

***
## 方法二：Python3+组合数学+隔板法
### 提交结果
- 执行用时： 28 ms , 在所有 Python3 提交中击败了 100.00% 的用户
- 内存消耗： 15 MB , 在所有 Python3 提交中击败了 23.66% 的用户
- 通过测试用例： 41 / 41
### 解题思路    

- 等价于将n个球放到m个盒子里且盒子可以为空的经典组合数学问题
### 性能优化

- 无

### 复杂度分析


- 设字符串长度为$n$，则有
  - 时间复杂度：$O(1)$
  - 空间复杂度：$O(1)$

### 代码

```#Python3
import math


class Solution:
    def countVowelStrings(self, n: int) -> int:
        return math.comb(n+4, 4)
```
***
## 方法三：深度优先搜索
### 提交结果
- 执行用时： 116 ms , 在所有 Python3 提交中击败了 73.37% 的用户
- 内存消耗： 21 MB , 在所有 Python3 提交中击败了 8.29% 的用户
- 通过测试用例： 112 / 112

### 解题思路

1. 有点类似于树形DP的思想，一个点是安全的当且仅当它的所有子节点也是安全的
2. 因此采用深搜的方式进行查询记录是否安全，同时使用一个访问数组进行记录避免重复查询

### 性能优化

- 无

### 复杂度分析

- 设节点个数为$n$，平均出度为$m$，则有
  - 时间复杂度：$O(nm)$
  - 空间复杂度：$O(nm)$

### 代码
```Python3
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        is_safe = [0]*n
        visit = [0]*n

        def dfs(i):
            if visit[i]:
                return is_safe[i]
            visit[i] = 1
            if not graph[i]:
                is_safe[i] = 1
                return 1

            for k in graph[i]:
                if visit[k] and not is_safe[k]:
                    is_safe[i] = 0
                    return 0
                else:
                    if not dfs(k):
                        is_safe[i] = 0
                        return 0
            is_safe[i] = 1
            return 1

        for j in range(n):
            dfs(j)

        return [i for i in range(n) if is_safe[i]]
```
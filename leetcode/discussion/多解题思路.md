# 【儿须成名酒须醉】Python3+Tarjan+逆向拓扑排序+深度优先搜索
***    
## 方法一：Tarjan 
### 提交结果     
- 执行用时： 360 ms , 在所有 Python3 提交中击败了 5.72% 的用户
- 内存消耗： 30.3 MB , 在所有 Python3 提交中击败了 5.13% 的用户
- 通过测试用例： 112 / 112

### 解题思路    

- 利用tarjan算法找出有向图中的环上节点，注意tarjan得到的结果还要加上自环的节点

### 性能优化

- 无

### 复杂度分析

- 设节点个数为$n$，平均出度为$m$，则有
    - 时间复杂度：$O(nm)$    
    - 空间复杂度：$O(nm)$   

### 代码
```Python3
from collections import defaultdict


class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        def check_graph(edge: List[list], n):
            # 访问序号与根节点序号
            visit = [0] * n
            root = [0] * n
            # 割点
            cut_node = []
            # 割边
            cut_edge = []
            # 强连通分量子树
            sub_group = []

            # 中间变量
            stack = []
            index = 1
            def tarjan(i):
                nonlocal index
                visit[i] = root[i] = index
                index += 1
                stack.append(i)
                for j in edge[i]:
                    if not visit[j]:
                        tarjan(j)
                        root[i] = min(root[i], root[j])
                        if visit[i] < root[j]:
                            cut_edge.append([i, j])
                        if visit[i] <= root[j]:
                            cut_node.append(i)
                    elif j in stack:
                        root[i] = min(root[i], visit[j])

                if root[i] == visit[i]:
                    lst = []
                    while stack[-1] != i:
                        lst.append(stack.pop())
                    lst.append(stack.pop())
                    r = min(root[ls] for ls in lst)
                    for ls in lst:
                        root[ls] = r
                    sub_group.append(lst)
                return

            for k in range(n):
                if not visit[k]:
                    tarjan(k)
            return cut_edge, cut_node, sub_group

        n = len(graph)
        _, _, sub_graph = check_graph(graph, n)

        # 根据强连通分量找出成环的节点
        stack = []
        for lst in sub_graph:
            if len(lst) > 1:
                stack.extend(lst)

        # 注意自环
        for i in range(n):
            if i in graph[i]:
                stack.append(i)

        # 反向广度优先搜索确认是否安全
        dct = defaultdict(list)
        for i in range(n):
            for j in graph[i]:
                dct[j].append(i)

        is_safe = [1]*n
        for i in stack:
            is_safe[i] = 0

        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    if is_safe[j]:
                        is_safe[j] = 0
                        nex.append(j)
            stack = nex[:]

        return [i for i in range(n) if is_safe[i]]
```

***
## 方法二：逆向拓扑排序
### 提交结果    
- 执行用时： 164 ms , 在所有 Python3 提交中击败了 23.47% 的用户
- 内存消耗： 20.6 MB , 在所有 Python3 提交中击败了 34.91% 的用户
- 通过测试用例： 112 / 112

### 解题思路    

- 逆向广度优先搜索，进行拓扑，从终端结点出发，搜索完后入度为0的即为安全节点

### 性能优化

- 无

### 复杂度分析


- 设节点个数为$n$，平均出度为$m$，则有
  - 时间复杂度：$O(nm)$
  - 空间复杂度：$O(nm)$

### 代码

```Python3
from collections import defaultdict


class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        # 建图
        n = len(graph)
        degree = defaultdict(int)
        dct = defaultdict(list)
        for i in range(n):
            for j in graph[i]:
                dct[j].append(i)
                degree[i] += 1

        # 广搜
        stack = [i for i in range(n) if not degree[i]]
        is_safe = [0]*n
        for i in stack:
            is_safe[i] = 1

        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    degree[j] -= 1
                    if not degree[j]:
                        is_safe[j] = 1
                        nex.append(j)
            stack = nex[:]

        return [i for i in range(n) if is_safe[i]]
```
***
## 方法三：深度优先搜索
### 提交结果
- 执行用时： 116 ms , 在所有 Python3 提交中击败了 73.37% 的用户
- 内存消耗： 21 MB , 在所有 Python3 提交中击败了 8.29% 的用户
- 通过测试用例： 112 / 112

### 解题思路

1. 有点类似于树形DP的思想，一个点是安全的当且仅当它的所有子节点也是安全的
2. 因此采用深搜的方式进行查询记录是否安全，同时使用一个访问数组进行记录避免重复查询

### 性能优化

- 无

### 复杂度分析

- 设节点个数为$n$，平均出度为$m$，则有
  - 时间复杂度：$O(nm)$
  - 空间复杂度：$O(nm)$

### 代码
```Python3
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        is_safe = [0]*n
        visit = [0]*n

        def dfs(i):
            if visit[i]:
                return is_safe[i]
            visit[i] = 1
            if not graph[i]:
                is_safe[i] = 1
                return 1

            for k in graph[i]:
                if visit[k] and not is_safe[k]:
                    is_safe[i] = 0
                    return 0
                else:
                    if not dfs(k):
                        is_safe[i] = 0
                        return 0
            is_safe[i] = 1
            return 1

        for j in range(n):
            dfs(j)

        return [i for i in range(n) if is_safe[i]]
```
# [【儿须成名酒须醉】第90场力扣夜喵双周赛题解]
***

### 写在前面
空杯心态心态心态心态心态心态心态心态心态，笑看竞赛分起起伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏！
![image.png](https://pic.leetcode.cn/1667058305-KINOua-image.png)


[【儿须成名酒须醉】第90场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-90/
***    
## [题目一: 差值数组不同的字符串]


[题目一: 差值数组不同的字符串]: https://leetcode.cn/contest/biweekly-contest-90/problems/odd-string-difference/
### 解题思路
不多说，T1就是要暴力才对！
- 暴力
### 代码
```python3
class Solution:
    def oddString(self, words: List[str]) -> str:
        n = len(words[0])
        ind = [tuple(ord(word[i + 1]) - ord(word[i]) for i in range(n - 1)) for word in words]
        cnt = Counter(ind)
        for i in range(len(ind)):
            if cnt[ind[i]] == 1:
                return words[i]
        return ""
```

### 复杂度分析
设字符串个数为$m$，每个字符串长度为$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$
***
## [题目二：距离字典两次编辑以内的单词]

[题目二：距离字典两次编辑以内的单词]: https://leetcode.cn/contest/biweekly-contest-90/problems/words-within-two-edits-of-dictionary/
### 解题思路
数据范围有限，使用暴力进行计算！
- 暴力
### 代码
```python3
class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        
        def dis(s, t):
            return sum(s[i] != t[i] for i in range(len(s)))

        def check(st):
            return any(dis(st, word) <= 2 for word in dictionary)
        return [word for word in queries if check(word)]
```
### 复杂度分析
设查询字符串数组长度为$n$，参考字符串数组长度为$m$，每个字符串长度为$k$，则有
- 时间复杂度$O(nmk)$
- 空间复杂度$O(nmk)$

***
## [题目三：摧毁一系列目标]

[题目三：摧毁一系列目标]: https://leetcode.cn/contest/biweekly-contest-90/problems/destroy-sequential-targets/

### 解题思路
由$nums[i]+c*space$可知，将数组中的每个数取模$space$，每个组的最小数选为给机器输入的数，这个数能摧毁的目标数即为这个组的数个数
- 贪心
- 取模
### 代码
```python3
class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:

        ind = defaultdict(list)
        for num in nums:
            ind[num % space].append(num)

        ans = pre = 0
        for k in ind:
            cnt = len(ind[k])
            num = min(ind[k])
            if cnt > pre or (cnt == pre and num < ans):
                ans = num
                pre = cnt
        return ans
```
### 复杂度分析
设数组的长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目四：下一个更大元素 IV]

[题目四：下一个更大元素 IV]: https://leetcode.cn/contest/biweekly-contest-90/problems/next-greater-element-iv/
### 解题思路
遍历数组，使用有序集合$pre$维护$[nums[i],i]$的元素组合，当遇到新的$nums[i]$时，从前往后将$pre$里面小于当前数对应的索引$k$进行$cnt[k]+1$，其中$cnt[k]$表示后面出现了比$nums[k]$更大的数的个数，当这个值达到2时，相应地就有$ans[k]=nums[i]$，则可以将$[nums[k],k]$将这个元素组合从$pre$当中抹去，由于Python3的list的pop(index)函数效率较低，使用SortList，不容易出现TLE
- 有序集合
- 计数
### 代码
```python3
from sortedcontainers import SortedList


class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        cnt = [0] * n
        pre = SortedList()
        for i in range(n):
            x = nums[i]
            j = 0
            while j < len(pre):
                num, k = pre[j]
                # 小于当前值的进行处理
                if num < x:
                    cnt[k] += 1
                    # 累计比nums[k]的数达到了2则出集合
                    if cnt[k] == 2:
                        ans[k] = x
                        pre.pop(j)
                    else:
                        j += 1
                # 比后面的数都小可直接终止
                else:
                    break
            pre.add([x, i])
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***
### 写在最后
再接再厉，明日再战！
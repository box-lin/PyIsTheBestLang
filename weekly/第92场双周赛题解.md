# [【儿须成名酒须醉】😺 第 92 场力扣夜喵双周赛]
***

### 写在前面
空杯心态心态心态心态心态心态心态心态心态，笑看竞赛分起起伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏！



[【儿须成名酒须醉】😺 第 92 场力扣夜喵双周赛]: https://leetcode.cn/contest/biweekly-contest-92/
***    
## [题目一: 分割圆的最少切割次数]


[题目一: 分割圆的最少切割次数]: https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-cuts-to-divide-a-circle/
### 解题思路
分为奇偶数考虑，偶数直接对半开，奇数只能一刀刀划，注意$n=1$时的边界条件
- 脑筋急转弯
- 边界条件
### 代码
```python3
class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n % 2 == 0:
            return n // 2
        return n if n > 1 else 0
```

### 复杂度分析
- 时间复杂度$O(1)$
- 空间复杂度$O(1)$
***
## [题目二：行和列中一和零的差值]

[题目二：行和列中一和零的差值]: https://leetcode.cn/contest/biweekly-contest-92/problems/difference-between-ones-and-zeros-in-row-and-column/
### 解题思路
直给的模拟题，预先计算好每行每列$1$的个数，再根据题意赋值即可
- 计数
- 模拟
### 代码
```python3
class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        row = [sum(g) for g in grid]
        col = [sum(grid[i][j] for i in range(m)) for j in range(n)]
        for i in range(m):
            for j in range(n):
                grid[i][j] = row[i] + col[j] - (n - row[i]) - (m - col[j])
        return grid
```
### 复杂度分析
设矩阵的行数与列数分别为$m$和$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(m+n)$

***
## [题目三：商店的最少代价]

[题目三：商店的最少代价]: https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-penalty-for-a-shop/

### 解题思路
枚举商店的关门时间，分别计算开门期间即前缀$N$的个数与关门期间即后缀$Y$的个数，可以使用一个变量遍历更新代价计数
- 枚举
- 遍历
### 代码
```python3
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        score = customers.count("Y")
        cost = [score]
        for w in customers:
            score += 1 if w == "N" else -1
            cost.append(score)
        return cost.index(min(cost))
```
### 复杂度分析
设日志长度为为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目四：统计回文子序列数目]

[题目四：统计回文子序列数目]: https://leetcode.cn/contest/biweekly-contest-92/problems/count-palindromic-subsequences/
### 解题思路
重点在于要求长度为$5$的回文子序列，因此枚举回文子序列的中间字符，取前后缀长度为$2$的子串进行乘积计数
- 枚举
- 计数
### 代码
```python3
MOD = 10 ** 9 + 7


class Solution:
    def countPalindromes(self, s: str) -> int:

        # 前缀计数
        pre = defaultdict(int)
        pre[""] = 1
        left = [pre.copy()]
        for w in s:
            cur = pre.copy()
            for p in list(pre.keys()):
                if len(p + w) <= 2:
                    cur[p + w] += pre[p]
            pre = cur.copy()
            left.append(pre.copy())

        # 后缀计数
        post = defaultdict(int)
        post[""] = 1
        ans = 0
        n = len(s)
        for i in range(n-1, -1, -1):
            for p in post:
                if len(p) == 2:
                    ans += left[i][p]*post[p]
                    ans %= MOD
            cur = post.copy()
            w = s[i]
            for p in list(post.keys()):
                if len(p + w) <= 2:
                    cur[p + w] += post[p]
            post = cur.copy()
        return ans
```
### 复杂度分析
设字符串长度为$n$，长度为$5$的回文子序列前半部分长度为$2$的字符数为$m=100$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$
***
### 写在最后
再接再厉，明日再战！
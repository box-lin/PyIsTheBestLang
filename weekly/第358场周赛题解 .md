

***

# [【儿须成名酒须醉】第 358 场力扣周赛题解]

***

### 竞赛日记
总是暴力TLE，常常WA掉分，偶尔无伤AK上分！

[【儿须成名酒须醉】第 358 场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-358/

***    
## [题目一: 数组中的最大数对和]
[题目一: 数组中的最大数对和]: https://leetcode.cn/contest/weekly-contest-358/problems/max-pair-sum-in-an-array/
【儿须成名酒须醉】Python3+哈希
### 解题思路
使用哈希记录前缀最大数位对应的最大值
- 哈希

### 代码
```python3
class Solution:
    def maxSum(self, nums: List[int]) -> int:
        ans = -1
        dct = defaultdict(int)
        for i, num in enumerate(nums):
            x = max(w for w in str(nums[i]))
            if dct[x]:
                if num + dct[x] > ans:
                    ans = num + dct[x]
            if num > dct[x]:
                dct[x] = num
        return ans
```
### 复杂度分析
将数字的数位长度以及哈希空间认定为常数，设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$

***
## [题目二：翻倍以链表形式表示的数字]

[题目二：翻倍以链表形式表示的数字]: https://leetcode.cn/contest/weekly-contest-358/problems/double-a-number-represented-as-a-linked-list/
【儿须成名酒须醉】Python3+暴力模拟+数组模拟
### 解题思路
直接使用py的大数模拟，注意整型的数字范围超限需要额外加一行代码
- 暴力模拟

使用数组形式表示整数，再进行链表生成
- 数组模拟



### 暴力模拟
```python3
sys.set_int_max_str_digits(0) # 特别重要，防止出现整数超限，默认不超过4300位数


class ListNodeOperation:
    def __init__(self):
        return

    @staticmethod
    def node_to_num(node: ListNode) -> int:
        num = 0
        while node:
            num = num * 10 + node.val
            node = node.next
        return num

    @staticmethod
    def num_to_node(num: int) -> ListNode:
        node = ListNode(-1)
        pre = node
        for x in str(num):
            pre.next = ListNode(int(x))
            pre = pre.next
        return node.next

    
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        lno = ListNodeOperation()
        num = lno.node_to_num(head)*2
        return lno.num_to_node(num)

```

### 数组模拟
```python3
class ListNodeOperation:
    def __init__(self):
        return

    @staticmethod
    def node_to_lst(node: ListNode) -> List[int]:
        lst = []
        while node:
            lst.append(node.val)
            node = node.next
        return lst

    @staticmethod
    def lst_to_node(lst: List[int]) -> ListNode:
        node = ListNode(-1)
        pre = node
        for num in lst:
            pre.next = ListNode(num)
            pre = pre.next
        return node.next

class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        lno = ListNodeOperation()
        lst = lno.node_to_lst(head)[::-1]

        nums = []
        x = 0
        for num in lst:
            x += num * 2
            nums.append(x % 10)
            x = 1 if x >= 10 else 0
        if x:
            nums.append(x)

        nums.reverse()
        return lno.lst_to_node(nums)
```


### 复杂度分析

暴力模拟的复杂度不祥，主要涉及到大数的运算，数组模拟的复杂度设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：限制条件下元素之间的最小绝对差]

[题目三：限制条件下元素之间的最小绝对差]: https://leetcode.cn/contest/weekly-contest-358/problems/minimum-absolute-difference-between-elements-with-constraint/
【儿须成名酒须醉】Python3+双指针+有序列表二分查找
### 解题思路
遍历数组，使用双指针维护前缀距离大于等于$x$的有序列表，二分查找离当前数字最近的几个数字计算结果
- 双指针
- 有序列表二分查找

### 代码
```python3
class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        lst = SortedList()
        j = 0
        n = len(nums)
        ans = inf
        for i in range(n):
            while j < n and j <= i - x:
                lst.add(nums[j])
                j += 1
            ind = lst.bisect_left(nums[i])
            for k in [ind - 1, ind]:  # 需要确定最近的左右两个数字
                if 0 <= k < len(lst) and abs(nums[i] - lst[k]) < ans:
                    ans = abs(nums[i] - lst[k])
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$

***
## [题目四：操作使得分最大]

[题目四：操作使得分最大]: https://leetcode.cn/contest/weekly-contest-358/problems/apply-operations-to-maximize-score/
【儿须成名酒须醉】Python3+质因数分解+单调栈作用域+贪心
### 解题思路
1. 首先每个数的质数分数就是其不同质因数的个数，这方面可以使用预处理方式获得给定数据范围的质因数个数结果（经典套路1）
2. 然后枚举每个数字作为质数分数最高的子数组个数，这方面可以使用质数分数数组计算单调栈作用域（经典套路2）
3. 将数组从大到小排序，依次累加子数组个数达到操作$k$次
- 数位DP

### 代码
```python3
class NumberTheoryPrimeFactor:
    def __init__(self, ceil):
        self.ceil = ceil
        self.prime_factor = [[] for _ in range(self.ceil + 1)]
        self.min_prime = [0] * (self.ceil + 1)
        self.get_min_prime_and_prime_factor()
        return

    def get_min_prime_and_prime_factor(self):
        # 模板：计算 1 到 self.ceil 所有数字的最小质数因子
        for i in range(2, self.ceil + 1):
            if not self.min_prime[i]:
                self.min_prime[i] = i
                for j in range(i * i, self.ceil + 1, i):
                    if not self.min_prime[j]:
                        self.min_prime[j] = i

        # 模板：计算 1 到 self.ceil 所有数字的质数分解（可选）
        for num in range(2, self.ceil + 1):
            i = num
            while num > 1:
                p = self.min_prime[num]
                cnt = 0
                while num % p == 0:
                    num //= p
                    cnt += 1
                self.prime_factor[i].append([p, cnt])
        return


# 经典套路1：质因数分解预处理
nt = NumberTheoryPrimeFactor(10**5+10)
mod = 10**9 + 7

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        factor = [len(nt.prime_factor[x]) for x in nums]
        ans = 1

        # 经典套路2：单调栈前后边界下标计算
        post = [n - 1] * n   # 这里可以是n/n-1/null，取决于用途
        pre = [0] * n   # 这里可以是0/-1/null，取决于用途
        stack = []
        for i in range(n):  # 这里也可以是从n-1到0倒序计算，取决于用途
            while stack and factor[stack[-1]] < factor[i]:  # 这里可以是"<" ">" "<=" ">="，取决于需要判断的大小关系
                post[stack.pop()] = i - 1  # 这里可以是i或者i-1，取决于是否包含i作为右端点
            if stack:  # 这里不一定可以同时计算，比如前后都是大于等于时，只有前后所求范围互斥时，可以计算
                pre[i] = stack[-1] + 1  # 这里可以是stack[-1]或者stack[-1]+1，取决于是否包含stack[-1]作为左端点
            stack.append(i)
        return

        # 贪心
        ind = list(range(n))
        ind.sort(key=lambda it: -nums[it])
        for i in ind:
            if not k:
                break
            x = (i - pre[i] + 1) * (post[i] - i + 1)  # 以i作为最大质数分数的子数组个数
            y = x if x < k else k
            k -= y
            ans *= pow(nums[i], y, mod)
            ans %= mod
        return ans
```


### 复杂度分析
不考虑质因数个数的预处理，乘法快速幂的计算，设数组长度为$n$，则有
- 时间复杂度$O(logn)$
- 空间复杂度$O(n)$
***

### 写在最后
谢谢阅读，继续努力，很久没写题解，后续有空多写写积累的各种py板子！
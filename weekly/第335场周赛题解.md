# [【儿须成名酒须醉】第335场力扣周赛题解]
***

### 写在前面
周赛分数，宛如有田下山，一路狂飙！

[【儿须成名酒须醉】第335场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-335/
***    
## [题目一: 递枕头]
[题目一: 递枕头]: https://leetcode.cn/contest/weekly-contest-335/problems/pass-the-pillow/
【儿须成名酒须醉】Python3+暴力模拟+数学
### 解题思路
根据题意暴力模拟即可，对于T1暴力就是yyds！
- 暴力
- 模拟
### 代码
```python3
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        pre = 1
        ind = 1
        for _ in range(time):
            if 1 <= pre + ind <= n:
                pre += ind
            else:
                ind *= -1
                pre += ind
        return pre
```
### 复杂度分析
设数字位数长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***

## [题目二：数组乘积中的不同质因数数目]

[题目二：数组乘积中的不同质因数数目]: https://leetcode.cn/contest/weekly-contest-335/problems/distinct-prime-factors-of-product-of-array/
【儿须成名酒须醉】Python3+质因数分解+模拟
### 解题思路
跟第324场周赛T2一样的思路，质因数分解模拟计数即可，奉上质因数分解板子！
- 质因数分解
- 模拟

### 代码
```python3
@lru_cache(None)
def get_prime_factor(x):
    # 模板：质因数分解最多支持 1**12
    ans = []
    j = 2
    while j * j <= x:
        if x % j == 0:
            c = 0
            while x % j == 0:
                x //= j
                c += 1
            ans.append([j, c])
        j += 1
    if x > 1:
        ans.append([x, 1])
    return ans


class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:
        ans = set()
        for num in nums:
            for x in get_prime_factor(num):
                if x[0] > 1:
                    ans.add(x[0])
        return len(ans)
```
### 复杂度分析
设数组长度为$n$，最大数字为$m$，通过预处理计算质因数分解则有
- 时间复杂度$O(n+mlogm)$
- 空间复杂度$O(n)$


***
## [题目三：将字符串分割成值不超过 K 的子字符串]

[题目三：将字符串分割成值不超过 K 的子字符串]: https://leetcode.cn/contest/weekly-contest-335/problems/partition-string-into-substrings-with-values-at-most-k/
【儿须成名酒须醉】Python3+贪心+模拟
### 解题思路
看到分割，想起第320场周赛的T4，这里就按照题意，贪心进行分割，注意特判不存在的情况即可！
- 贪心
- 模拟

### 代码
```python3
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        
        if any(int(w) > k for w in s):
            return -1
        
        ans = 0
        pre = ""
        for w in s:
            if int(pre + w) <= k:
                pre += w
            else:
                ans += 1
                pre = w
        return ans + 1
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$

***
## [题目四：范围内最接近的两个质数]

[题目四：范围内最接近的两个质数]: https://leetcode.cn/contest/weekly-contest-335/problems/closest-prime-numbers-in-range/
【儿须成名酒须醉】Python3+素数筛（埃氏筛、欧拉筛）+模拟
### 解题思路
按照题意，预处理数据范围内的素数，然后遍历枚举计算，奉上板子！
- 素数筛（埃氏筛、欧拉筛）
- 模拟

### 代码
```python3

def sieve_of_eratosthenes(n):  # 埃拉托色尼筛选法，返回小于等于n的素数
    primes = [True] * (n + 1)  # 范围0到n的列表
    p = 2  # 这是最小的素数
    while p * p <= n:  # 一直筛到sqrt(n)就行了
        if primes[p]:  # 如果没被筛，一定是素数
            for i in range(p * 2, n + 1, p):  # 筛掉它的倍数即可
                primes[i] = False
        p += 1
    primes = [element for element in range(2, n + 1) if primes[element]]  # 得到所有小于等于n的素数
    return primes

def euler_flag_prime(n):
    # 欧拉线性筛素数，返回小于等于n的所有素数
    flag = [False for _ in range(n + 1)]
    prime_numbers = []
    for num in range(2, n + 1):
        if not flag[num]:
            prime_numbers.append(num)
        for prime in prime_numbers:
            if num * prime > n:
                break
            flag[num * prime] = True
            if num % prime == 0:
                break
    return prime_numbers


primes = euler_flag_prime(10**6)
# primes = sieve_of_eratosthenes(10**6)


class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        res = [x for x in primes if left <= x <= right]
        ans = []
        m = len(res)
        for i in range(m - 1):
            x, y = res[i], res[i + 1]
            if not ans or y - x < ans[1] - ans[0]:
                ans = [x, y]
        return ans if ans else [-1, -1]
```


### 复杂度分析
设数据最大为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***

### 写在最后
谢谢阅读，继续努力！
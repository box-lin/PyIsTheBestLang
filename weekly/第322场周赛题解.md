# [【儿须成名酒须醉】第322场力扣周赛题解]
***

### 写在前面
大道三千，最怕就是钻牛角尖！


[【儿须成名酒须醉】第322场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-322/
***    
## [题目一: 回环句]
[题目一: 回环句]: https://leetcode.cn/contest/weekly-contest-322/problems/circular-sentence/

### 解题思路
根据题意模拟即可
- 模拟
- 字符串
### 代码
```python3
class Solution:
    def isCircularSentence(self, sentence: str) -> bool:
        lst = sentence.split(" ")
        n = len(lst)
        if any(lst[i + 1][0] != lst[i][-1] for i in range(n - 1)):
            return False
        return lst[-1][-1] == lst[0][0]
```
### 复杂度分析
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目二：划分技能点相等的团队]

[题目二：划分技能点相等的团队]: https://leetcode.cn/contest/weekly-contest-322/problems/divide-players-into-teams-of-equal-skill/
### 解题思路
首先计算分配对的技能点和看是否存在可能，然后使用哈希计数贪心进行分配，最后判断是否完全分配即可
- 哈希计数
- 贪心
### 代码
```python3
class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        s, n = sum(skill), len(skill)

        # 不能整除则无法分配
        if s % (n // 2):
            return -1
        
        m = s // (n // 2)
        pre = defaultdict(int)
        ans = 0
        for num in skill:
            if pre[m - num]:
                # 和已有的分配
                ans += num * (m - num)
                pre[m - num] -= 1
            else:
                # 加入待选分配
                pre[num] += 1
        return ans if max(pre.values()) == 0 else -1
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：从两个城市间路径的最小分数]

[题目三：两个城市间路径的最小分数]: https://leetcode.cn/contest/weekly-contest-322/problems/minimum-score-of-a-path-between-two-cities/
### 解题思路
可以使用经典的带约束最短路做法，这里求的是路径上所有边最小距离，因此需要不断更新$1$到某个点的最短距离 
- Dijkstra
- 模拟

### 代码
```python3
class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        dct = [dict() for _ in range(n + 1)]
        for i, j, c in roads:
            dct[i][j] = c
            dct[j][i] = c
        # Dijkstra
        visit = [float("inf")] * (n + 1)
        stack = [[dct[1][j], 1] for j in dct[1]]
        while stack:
            dis, i = heapq.heappop(stack)
            if visit[i] <= dis:
                # 已经搜寻过更短的距离则跳过
                continue
            visit[i] = dis
            for j in dct[i]:
                heapq.heappush(stack, [min(dis, dct[i][j]), j])
        return visit[n]
```
### 复杂度分析
设节点个数为$n$
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$

### 优化
没仔细读题目，可以无限次经过节点和边，所以本质上是求连通子集边的距离最小值Orz
- 脑筋急转弯
- 并查集
```python3
# 标准并查集
class UnionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1] * n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def get_root_part(self):
        # 获取每个根节点对应的组
        part = defaultdict(set)
        n = len(self.root)
        for i in range(n):
            part[self.find(i)].add(i)
        return part

    def get_root_size(self):
        # 获取每个根节点对应的组大小
        size = defaultdict(int)
        n = len(self.root)
        for i in range(n):
            size[self.find(i)] = self.size[self.find(i)]
        return size



class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        uf = UnionFind(n)
        for i, j, c in roads:
            uf.union(i-1, j-1)
        ans = float("inf")
        for x, y, c in roads:
            if uf.is_connected(0, x- 1) and uf.is_connected(0, y- 1):
                ans = ans if ans < c else c
        return ans
```
***
## [题目四：将节点分成尽可能多的组]

[题目四：将节点分成尽可能多的组]: https://leetcode.cn/contest/weekly-contest-322/problems/divide-nodes-into-the-maximum-number-of-groups/
### 解题思路
首先将图分割成一个个连通子集，然后子集内部枚举作为第一组的点，使用广度优先搜索匹配剩下的点，再判断每条边是否符合两个端点属于临近的组，符合条件则更新最多组数
- 并查集
- 枚举
- 贪心
- 广度优先搜索

### 代码
```python3
# 标准并查集
class UnionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1] * n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def get_root_part(self):
        # 获取每个根节点对应的组
        part = defaultdict(set)
        n = len(self.root)
        for i in range(n):
            part[self.find(i)].add(i)
        return part

    def get_root_size(self):
        # 获取每个根节点对应的组大小
        size = defaultdict(int)
        n = len(self.root)
        for i in range(n):
            size[self.find(i)] = self.size[self.find(i)]
        return size


class Solution:
    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:

        def check(cur_nodes, cur_edges):
            
            # 检查连通子集最大的分组数
            degree = defaultdict(int)
            for x, y in cur_edges:
                degree[x] += 1
                degree[y] += 1
            cur_nodes.sort(key=lambda node: degree[node])
        
            res = 0
            # 按照节点的度进行排序剪枝只选度最小的点作为起点（贪心180ms求证明，暴力3200ms也能过）
            for z in [node for node in cur_nodes if degree[node] == degree[cur_nodes[0]]]:
                stack = [z]
                root = defaultdict(int)
                group = 1
                root[z] = group
                while stack:
                    nex = []
                    group += 1
                    for x in stack:
                        for y in dct[x]:
                            if not root[y]:
                                root[y] = group
                                nex.append(y)
                    stack = nex
                group -= 1
                if all(abs(root[x] - root[y]) == 1 for x, y in cur_edges):
                    res = res if res > group else group
            return res
        
        # 生成连通子集
        dct = [[] for _ in range(n)]
        uf = UnionFind(n)
        for i, j in edges:
            i -= 1
            j -= 1
            dct[i].append(j)
            dct[j].append(i)
            uf.union(i, j)
        part = uf.get_root_part()
        ans = 0
        # 遍历每个连通子集查看可分情况
        for p in part:
            p_nodes = list(part[p])
            p_edges = [[x - 1, y - 1] for x, y in edges if x - 1 in part[p] and y - 1 in part[p]]
            p_group = check(p_nodes, p_edges)
            # 不可分直接返回
            if p_group == 0:
                return -1
            ans += p_group
        return ans
```


### 复杂度分析n
设数组长度为$n$，则有
- 时间复杂度$O(n^2logn)$
- 空间复杂度$O(n^2logn)$
***

### 写在最后
谢谢阅读，继续努力！

## 最大公约数
```Python3
# 第一种
import math
math.gcd(x, y)

# 第二种
def gcd(x, y):
    if y == 0:
        return x
    else:
        return gcd(y, x % y)
        
```
## 最小公倍数
```Python3
import math
math.lcm(x, y)

```
## 获取整数所有的因子
```Python3
import math
def get_all_factor(num):
    factor = set()
    for i in range(1, int(math.sqrt(num))+1):
        if num % i == 0:
            factor.add(i)
            factor.add(num//i)
    
    return sorted(list(factor))
```
## 获取整数所有的质数因子
```Python3
from functools import lru_cache
import math

@lru_cache(None)
def get_prime_factor(num):
    if num == 1:
        return []
    ans = set()
    for i in range(2, int(math.sqrt(num))+2):
        if num % i == 0:
            num //= i
            ans.add(i)
            ans = ans.union(get_prime_factor(num))
            return ans
    ans.add(num)
    return ans
```
## 质因数分解
```python3
@lru_cache(None)
def get_prime_part(num):
    ans = []
    for f in get_prime_factor(num):
        cnt = 0
        x = num
        while x %f == 0:
            x //= f
            cnt += 1
        ans.append([f, cnt])
    return ans
```


## n位数格雷码
```python3
dp = [[0, 1]]
for i in range(1, 16):
    cur = dp[-1] + [1 << i + num for num in dp[-1][::-1]]
    dp.append(cur)
```
```python
# =================================== 格雷码转换 ====================================
def graycode_to_integer(graycode):
    graycode_len = len(graycode)
    binay = []
    binay.append(graycode[0])
    for i in range(1, graycode_len):
        if graycode[i] == binay[i-1]:
            b = 0
        else:
            b = 1
        binay.append(str(b))
    return bin_to_inter(''.join(binay))
def bin_to_inter(binay):
    sum = 0
    length = len(binay)
    for i in range(0 , length):
        num = int(binay[i])*(2**(length - i - 1))
        sum = sum + num
    return sum
def integer_to_graycode(integer):
    binay = bin(integer).replace('0b', '')
    graycode = []
    binay_len = len(binay)
    graycode.append(binay[0])
    for i in range(1, binay_len):
        if binay[i-1] == binay[i]:
            g = 0
        else:
            g = 1
        graycode.append(str(g))
    return ''.join(graycode)
# =================================== 测试 ====================================
print(integer_to_graycode(22))
print(graycode_to_integer("10110"))
# =================================== 结果====================================
11101
27
————————————————
版权声明：本文为CSDN博主「就到这个秋天」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35473473/article/details/106320878
## 格雷码转二进制
```python3
def gray2binary(n: str) -> str:
    n = int(n, 2)
    mask = n
    while mask:
        mask >>= 1
        n ^= mask
    return bin(n)[2:].zfill(4)

def gray2binary(n: int) -> int:
    mask = n
    while mask:
        mask >>= 1
        n ^= mask
    return n
```
## 二进制转格雷码
```python3
def binary2gray(n):
    n = int(n, 2)
    return bin(n^(n>>1))[2:].zfill(4)
```

## 判断数是否为质数 
```Python3

def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, min(int(math.sqrt(num))+2, num)):
        if num%i == 0:
            return False
    return True
```

## 欧拉函数小于等于n的与n互质的个数
```Python3
import math

# 注意1和1互质，而大于1的质数与1不互质
def euler_phi(n):
    ans = n
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            ans = ans // i * (i - 1)
            while n % i == 0:
                n = n // i
    if n > 1:
        ans = ans // n * (n - 1)
    return int(ans)
```

## 埃拉托色尼筛选法（素数筛选法）
```Python3

def Eratosthenes(n):
    p = 0
    is_prime = [True]*(n+1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, n + 1):
        if is_prime[i]:
            is_prime[p] = i
            p = p + 1
            if i * i <= n:
                j = i * i
                while j <= n:
                    is_prime[j] = False
                    j = j + i
    return p

def sieve_of_eratosthenes(n):#埃拉托色尼筛选法，返回少于n的素数
    primes = [True] * (n+1)#范围0到n的列表
    p = 2#这是最小的素数
    while p * p <= n:#一直筛到sqrt(n)就行了
        if primes[p]:#如果没被筛，一定是素数
            for i in range(p * 2, n + 1, p):#筛掉它的倍数即可
                primes[i] = False
        p += 1
    primes = [element for element in range(2, n+1) if primes[element]]#得到所有少于n的素数
    return len(primes)
```

### 阶乘后的后缀零个数

```Python3

def compute(num):
    cnt = 0
    while num > 0:
        cnt += num//5
        num //= 5
    return cnt
        

```

## 整数n的k进制计算

```Python3
def get_k_bin_of_n(n: int, k: int) -> int:
    lst = []
    while n:
        lst.append(n % k)
        n //= k
    return lst[::-1]
```

# 有理数循环小数化为分数
```python3
1.2727=(27/99)+1
1.571428571428······=(571428/999999)+1
有n位循环
(循环部分/n位9)+整数部分 最后约简
```


## 注意哈希碰撞，需要取两个质数与模进行区分
```python3
P = 131
MOD = 10**9 + 7
DP = [1]
for i in range(1, 1501):
    DP.append((DP[-1] * P) % MOD)


class Solution:
    def longestDupSubstring(self, s: str) -> str:
        @lru_cache(None)
        def check(k):
            pre = set()
            num = 0
            for i in range(k):
                num += DP[k - 1 - i] * (ord(s[i]) - ord('a'))
                num %= MOD
            pre.add(num)
            for i in range(k, n):
                num -= DP[k - 1] * (ord(s[i - k]) - ord('a'))
                num *= P
                num += DP[0] * (ord(s[i]) - ord('a'))
                num %= MOD
                if num in pre:
                    return True, s[i-k+1:i+1]
                pre.add(num)
            return False, ""

        n = len(s)
        low = 0
        high = n-1
        while low < high-1:
            mid = low+(high-low)//2
            if check(mid)[0]:
                low = mid
            else:
                high = mid
        flag, st = check(high)
        if flag:
            return st
        return check(low)[1]
```


```python3
# https://leetcode.cn/problems/longest-duplicate-substring/solution/er-xu-cheng-ming-jiu-xie-xu-zui-by-liupe-h75p/
import random


P1 = random.randint(26, 100)
P2 = random.randint(26, 100)
MOD1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
MOD2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

DP1 = [1]
for _ in range(1, 3 * 10**4 + 1):
    DP1.append((DP1[-1] * P1) % MOD1)
DP2 = [1]
for _ in range(1, 3 * 10**4 + 1):
    DP2.append((DP2[-1] * P2) % MOD2)

class Solution:
    def longestDupSubstring(self, s: str) -> str:

        def check(k):
            pre = set()
            num1 = num2 = 0
            for i in range(k):
                num1 += DP1[k - 1 - i] * (ord(s[i]) - ord('a'))
                num1 %= MOD1
                num2 += DP2[k - 1 - i] * (ord(s[i]) - ord('a'))
                num2 %= MOD2
                
            pre.add((num1, num2))
            for i in range(k, n):
                num1 -= DP1[k - 1] * (ord(s[i - k]) - ord('a'))
                num1 *= P1
                num1 += DP1[0] * (ord(s[i]) - ord('a'))
                num1 %= MOD1

                num2 -= DP2[k - 1] * (ord(s[i - k]) - ord('a'))
                num2 *= P2
                num2 += DP2[0] * (ord(s[i]) - ord('a'))
                num2 %= MOD2
                if (num1, num2) in pre:
                    return True, s[i - k + 1: i + 1]
                pre.add((num1, num2))
            return False, ""

        n = len(s)
        low = 0
        high = n - 1
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid)[0]:
                low = mid
            else:
                high = mid
        flag, st = check(high)
        if flag:
            return st
        return check(low)[1]
```
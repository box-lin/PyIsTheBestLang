

```python3
from sortedcontainers import SortedList
from itertools import accumulate
from itertools import permutations

class SegmentTreeArray:
    def __init__(self, n: int):
        self.n = n
        self.min = [0] * (n * 4)
        self.sum = [0] * (n * 4)
        self.max = [0] * (n * 4)

    # 将 idx 上的元素值增加 val
    def add(self, o: int, l: int, r: int, idx: int, val: int) -> None:
        if l == r:
            self.min[o] += val
            self.sum[o] += val
            self.max[o] += val
            return
        m = (l + r) // 2
        if idx <= m: 
            self.add(o * 2, l, m, idx, val)
        else: 
            self.add(o * 2 + 1, m + 1, r, idx, val)
        self.min[o] = min(self.min[o * 2], self.min[o * 2 + 1])
        self.max[o] = max(self.max[o * 2], self.max[o * 2 + 1])
        self.sum[o] = self.sum[o * 2] + self.sum[o * 2 + 1]

    # 返回区间 [L,R] 内的元素和
    def query_sum(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.sum[o]
        sum = 0
        m = (l + r) // 2
        if L <= m: 
            sum += self.query_sum(o * 2, l, m, L, R)
        if R > m: 
            sum += self.query_sum(o * 2 + 1, m + 1, r, L, R)
        return sum

    # 返回区间 [L,R] 内的最小值
    def query_min(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.min[o]
        res = 10**9 + 7
        m = (l + r) // 2
        if L <= m: 
            res = min(res, self.query_min(o * 2, l, m, L, R))
        if R > m: 
            res = min(res, self.query_min(o * 2 + 1, m + 1, r, L, R))
        return res
    
    # 返回区间 [L,R] 内的最大值
    def query_max(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.max[o]
        res = 0
        m = (l + r) // 2
        if L <= m: 
            res = max(res, self.query_max(o * 2, l, m, L, R))
        if R > m: 
            res = max(res, self.query_max(o * 2 + 1, m + 1, r, L, R))
        return res


class BookMyShow:

    def __init__(self, n: int, m: int):
        self.m = m
        self.n = n
        self.array = SegmentTreeArray(n)
        for i in range(n):
            self.array.add(1, 1, n, i+1, m)
        self.seats = [m]*n
        self.null = SortedList(list(range(n)))
        

    def gather(self, k: int, maxRow: int) -> List[int]:
        val = self.array.query_max(1, 1, self.n, 1, maxRow+1)
        if val < k:
            return []
        
        low = 1
        high = maxRow + 1
        while low < high-1:
            mid = low+(high-low)//2
            if self.array.query_max(1, 1, self.n, 1, mid) >= k:
                high = mid
            else:
                low = mid
        i = low if self.array.query_max(1, 1, self.n, 1, low) >= k else high
        ans = [i-1, self.m-self.seats[i-1]]
        self.seats[i-1] -= k
        self.array.add(1, 1, self.n, i, -k)
        if not self.seats[i-1]:
            self.null.discard(i-1)
        return ans

    def scatter(self, k: int, maxRow: int) -> bool:
        if self.array.query_sum(1, 1, self.n, 1, maxRow+1) < k:
            return False
        for i in self.null[:]:
            add = min(k, self.seats[i])
            self.seats[i] -= add
            k -= add
            self.array.add(1, 1, self.n, i+1, -add)
            if not self.seats[i]:
                self.null.discard(i)
            if not k:
                break
        return True


# Your BookMyShow object will be instantiated and called as such:
# obj = BookMyShow(n, m)
# param_1 = obj.gather(k,maxRow)
# param_2 = obj.scatter(k,maxRow)

作者：liupengsay
链接：https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution/by-liupengsay-bqd5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```Python3
# 点求最大值
from collections import defaultdict
from sortedcontainers import SortedDict

class SegmentTree:
    def __init__(self):
        self.skyline = defaultdict(int)
        self.lazy = defaultdict(int)
        return

    def push_down(self, i):
        if self.lazy[i]:
            self.skyline[2*i] = max(self.skyline[2*i], self.lazy[i])
            self.skyline[2*i+1] = max(self.skyline[2*i+1], self.lazy[i])

            self.lazy[2*i] = max(self.lazy[2*i], self.lazy[i])
            self.lazy[2*i+1] = max(self.lazy[2*i+1], self.lazy[i])

            self.lazy[i] = 0
        return

    def update(self, l, r, h, s, t, i):
        if l <= s and t<=r:
            self.skyline[i] = max(self.skyline[i], h)
            self.lazy[i] = max(self.lazy[i], h)
            return

        m = s+(t-s)//2
        self.push_down(i)
        if l<=m:
            self.update(l, r, h, s, m, 2*i)
        if r>m:
            self.update(l, r, h, m+1, t, 2*i+1)

        self.skyline[i] = max(self.skyline[2*i], self.skyline[2*i+1])
        return

    def query(self, l, r, s, t, i):
        if l <= s and t<=r:
            return self.skyline[i]

        m = s+(t-s)//2
        self.push_down(i)
        ans = 0
        if l<=m:
            ans = max(ans, self.query(l, r, s, m, 2*i))
        if r>m:
            ans = max(ans, self.query(l, r, m+1, t, 2*i+1))
        return ans


class Solution:
    @staticmethod
    def getSkyline(buildings: List[List[int]]) -> List[List[int]]:
        segment_tree = SegmentTree()
        ceil = 2**31
        nodes = SortedDict()
        for l, r, h in buildings:
            segment_tree.update(l+1, r, h, 1, ceil, 1)
            nodes[l+1] = 1
            nodes[r+1] = 1

        pre = 0
        ans = []
        for k in nodes:
            h = segment_tree.query(k, k, 1, ceil, 1)
            if h != pre:
                ans.append([k-1, h])
            pre = h
        return ans
```

```Python3
# 区间覆盖
from collections import defaultdict

class SegmentTree:
    def __init__(self):
        self.cover = defaultdict(lambda: 1)
        self.lazy = defaultdict(int)
        self.count = 0

    def push_down(self, i):
        if self.lazy[i]:
            self.cover[2*i] = self.lazy[i]
            self.cover[2*i+1] = self.lazy[i]

            self.lazy[2*i] = self.lazy[i]
            self.lazy[2*i+1] = self.lazy[i]

            self.lazy[i] = 0


    def update(self, l, r, s, t, val, i):
        if l<=s and t<=r:
            self.cover[i] = val
            self.lazy[i] = val
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l<=m:
            self.update(l, r, s, m, val, 2*i)
        if r>m:
            self.update(l, r, m+1, t, val, 2*i+1)
        if self.cover[2*i] == self.cover[2*i+1] and self.cover[2*i+1]:
            self.cover[i] = self.cover[2*i+1]
        else:
            self.cover[i] = 0
        return

    def query(self, l, r, s, t, i):
        
        if self.cover[i]:
            self.count += (self.cover[i] == 2)*(t-s+1)
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l <= m:
            self.query(l, r, s, m, 2*i)
        if r > m:
            self.query(l, r, m+1, t, 2*i+1)
        return 


class Solution:
    def getNumber(self, root: Optional[TreeNode], ops: List[List[int]]) -> int:

        def pre_order(node):
            if not node:
                return []
            return pre_order(node.left) + [node.val] + pre_order(node.right)

        values = pre_order(root)
        n = len(values)

        left_ind = dict()
        right_ind = dict()
        for i, value in enumerate(values):
            if value not in left_ind:
                left_ind[value] = i
            right_ind[value] = i

        low = 0
        high = n - 1
        segment = SegmentTree()
        for tp, x, y in ops:
            left = left_ind[x]
            right = right_ind[y]
            segment.update(left, right, low, high, tp+1, 1)
        segment.query(low, high, low, high, 1)
        return segment.count
```


```Python3
# 区间求和
from collections import defaultdict

class SegmentTree:
    def __init__(self):
        self.cover = defaultdict(int)
        self.lazy = defaultdict(int)
        self.count = 0

    def push_down(self, i):
        if self.lazy[i]:
            self.cover[2*i] = self.lazy[i]
            self.cover[2*i+1] = self.lazy[i]

            self.lazy[2*i] = self.lazy[i]
            self.lazy[2*i+1] = self.lazy[i]

            self.lazy[i] = 0

    def update(self, l, r, s, t, val, i):
        if l <= s and t <= r:
            self.cover[i] = val
            self.lazy[i] = val
            return

        self.push_down(i)
        m = s+(t-s)//2
        if l<=m:
            self.update(l, r, s, m, val, 2*i)
        if r>m:
            self.update(l, r, m+1, t, val, 2*i+1)
        self.cover[i] = self.cover[2*i] + self.cover[2*i+1]
        return

    def query(self, l, r, s, t, i):
        if l<=s and t<=r:
            return self.cover[i]
        self.push_down(i)
        m = s+(t-s)//2
        ans = 0
        if l <= m:
            ans += self.query(l, r, s, m, 2*i)
        if r > m:
            ans += self.query(l, r, m+1, t, 2*i+1)
        return ans
```

```python3
from sortedcontainers import SortedList
from itertools import accumulate
from itertools import permutations

class SegmentTreeArray:
    def __init__(self, n: int):
        self.n = n
        self.min = [0] * (n * 4)
        self.sum = [0] * (n * 4)
        self.max = [0] * (n * 4)

    # 将 idx 上的元素值增加 val
    def add(self, o: int, l: int, r: int, idx: int, val: int) -> None:
        if l == r:
            self.min[o] += val
            self.sum[o] += val
            self.max[o] += val
            return
        m = (l + r) // 2
        if idx <= m: 
            self.add(o * 2, l, m, idx, val)
        else: 
            self.add(o * 2 + 1, m + 1, r, idx, val)
        self.min[o] = min(self.min[o * 2], self.min[o * 2 + 1])
        self.max[o] = max(self.max[o * 2], self.max[o * 2 + 1])
        self.sum[o] = self.sum[o * 2] + self.sum[o * 2 + 1]

    # 返回区间 [L,R] 内的元素和
    def query_sum(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.sum[o]
        sum = 0
        m = (l + r) // 2
        if L <= m: 
            sum += self.query_sum(o * 2, l, m, L, R)
        if R > m: 
            sum += self.query_sum(o * 2 + 1, m + 1, r, L, R)
        return sum

    # 返回区间 [L,R] 内的最小值
    def query_min(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.min[o]
        res = 10**9 + 7
        m = (l + r) // 2
        if L <= m: 
            res = min(res, self.query_min(o * 2, l, m, L, R))
        if R > m: 
            res = min(res, self.query_min(o * 2 + 1, m + 1, r, L, R))
        return res
    
    # 返回区间 [L,R] 内的最大值
    def query_max(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R: 
            return self.max[o]
        res = 0
        m = (l + r) // 2
        if L <= m: 
            res = max(res, self.query_max(o * 2, l, m, L, R))
        if R > m: 
            res = max(res, self.query_max(o * 2 + 1, m + 1, r, L, R))
        return res


class BookMyShow:

    def __init__(self, n: int, m: int):
        self.m = m
        self.n = n
        self.array = SegmentTreeArray(n)
        for i in range(n):
            self.array.add(1, 1, n, i+1, m)
        self.seats = [m]*n
        self.null = SortedList(list(range(n)))
        

    def gather(self, k: int, maxRow: int) -> List[int]:
        val = self.array.query_max(1, 1, self.n, 1, maxRow+1)
        if val < k:
            return []
        
        low = 1
        high = maxRow + 1
        while low < high-1:
            mid = low+(high-low)//2
            if self.array.query_max(1, 1, self.n, 1, mid) >= k:
                high = mid
            else:
                low = mid
        i = low if self.array.query_max(1, 1, self.n, 1, low) >= k else high
        ans = [i-1, self.m-self.seats[i-1]]
        self.seats[i-1] -= k
        self.array.add(1, 1, self.n, i, -k)
        if not self.seats[i-1]:
            self.null.discard(i-1)
        return ans

    def scatter(self, k: int, maxRow: int) -> bool:
        if self.array.query_sum(1, 1, self.n, 1, maxRow+1) < k:
            return False
        for i in self.null[:]:
            add = min(k, self.seats[i])
            self.seats[i] -= add
            k -= add
            self.array.add(1, 1, self.n, i+1, -add)
            if not self.seats[i]:
                self.null.discard(i)
            if not k:
                break
        return True


# Your BookMyShow object will be instantiated and called as such:
# obj = BookMyShow(n, m)
# param_1 = obj.gather(k,maxRow)
# param_2 = obj.scatter(k,maxRow)

作者：liupengsay
链接：https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution/by-liupengsay-bqd5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
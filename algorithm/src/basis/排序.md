
## 自定义排序
```python3
class Solution:
    def minNumber(self, nums: List[int]) -> str:
        def quick_sort(l , r):
            if l >= r: return
            i, j = l, r
            while i < j:
                while strs[j] + strs[l] >= strs[l] + strs[j] and i < j: j -= 1
                while strs[i] + strs[l] <= strs[l] + strs[i] and i < j: i += 1
                strs[i], strs[j] = strs[j], strs[i]
            strs[i], strs[l] = strs[l], strs[i]
            quick_sort(l, i - 1)
            quick_sort(i + 1, r)
        
        strs = [str(num) for num in nums]
        quick_sort(0, len(strs) - 1)
        return ''.join(strs)

作者：jyd
链接：https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
https://leetcode.cn/problems/largest-number/submissions/
```Python3
from functools import cmp_to_key

class Solution:
    def minNumber(self, nums: List[int]) -> str:
        def compare(x, y):
            return (x+y) < (y+x)
        nums = [str(num) for num in nums]
        nums.sort(key=cmp_to_key(compare))
        return "".join(nums)
```

## 选择排序
```Python3
def selection_sort(nums):
    n = len(nums)
    for i in range(n):
        ith = i
        for j in range(i + 1, n):
            if nums[j] < nums[ith]:
                ith = j
        nums[i], nums[ith] = nums[ith], nums[i]
    return nums
```

## 冒泡排序
```Python3
def bubble_sort(nums):
    n = len(nums)
    flag = True
    while flag:
        flag = False
        for i in range(n-1):
            if nums[i] > nums[i + 1]:
                flag = True
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
    return nums
```

## 插入排序
```Python3
def insertion_sort(nums):
    n = len(nums)
    for i in range(1, n):
        key = nums[i]
        j = i - 1
        while j >= 0 and nums[j] > key:
            nums[j + 1] = nums[j]
            j = j - 1
        nums[j+1] = key
    return nums
```

## 计数排序

```Python3
from collections import Counter


def counting_sort(nums):
    count = Counter(nums)
    keys = sorted(count.keys())
    rank = 0
    for key in keys:
        while count[key]:
            nums[rank] = key
            count[key] -= 1
            rank += 1
    return nums
```

## 快速排序
```Python3
def quick_sort(nums):
    def recursion(first, last):
        if first >= last:
            return
        mid_value = nums[first]
        low = first
        high = last
        while low < high:
            while low < high and nums[high] >= mid_value:
                high -= 1
            nums[low] = nums[high]
            while low < high and nums[low] < mid_value:
                low += 1
            nums[high] = nums[low]
        nums[low] = mid_value
        recursion(first, low - 1)
        recursion(low + 1, last)
    recursion(0, len(nums)-1)
    return nums
```
## 两路快排
```python3
class Solution:
    def sortArray(self, lst: List[int]) -> List[int]:
        n = len(lst)
        def quick_sort(i, j):
            if i >= j:
                return
            val = lst[random.randint(i, j)]
            left = i
            for k in range(i, j+1):
                if lst[k] < val:
                    lst[k], lst[left] = lst[left], lst[k]
                    left += 1

            quick_sort(i, left-1)
            for k in range(i, j + 1):
                if lst[k] == val:
                    lst[k], lst[left] = lst[left], lst[k]
                    left += 1
            quick_sort(left, j)
            return


        quick_sort(0, n-1)
        return lst
```
## 三路快排
```Python3
import random


def quick_sort_three(nums):
    def recursion(first, last):
        if first >= last:
            return
        random_index = random.randint(first, last)
        pivot = nums[random_index]
        nums[first], nums[random_index] = nums[random_index], nums[first]
        i = first + 1
        j = first
        k = last + 1
        while i < k:
            if nums[i] < pivot:
                nums[i], nums[j + 1] = nums[j + 1], nums[i]
                j += 1
                i += 1
            elif nums[i] > pivot:
                nums[i], nums[k - 1] = nums[k - 1], nums[i]
                k -= 1
            else:
                i += 1
        nums[first], nums[j] = nums[j], nums[first]
        recursion(first, j - 1)
        recursion(k, last)
    recursion(0, len(nums)-1)
    return nums
```
## 归并排序
```Python3
def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums)//2
        left = nums[:mid]
        right = nums[mid:]

        merge_sort(left)
        merge_sort(right)

        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            nums[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            nums[k] = right[j]
            j += 1
            k += 1
    return nums
```

## 堆排序
```Python3
def heap_sort(nums):

    def sift_down(start, end):
        # 计算父结点和子结点的下标
        parent = int(start)
        child = int(parent * 2 + 1)
        # 子结点下标在范围内才做比较
        while child <= end:
            # 先比较两个子结点大小，选择最大的
            if child + 1 <= end and nums[child] < nums[child + 1]:
                child += 1
            # 如果父结点比子结点大，代表调整完毕，直接跳出函数
            if nums[parent] >= nums[child]:
                return
            # 否则交换父子内容，子结点再和孙结点比较
            else:
                nums[parent], nums[child] = nums[child], nums[parent]
                parent = child
                child = int(parent * 2 + 1)
        return

    length = len(nums)
    # 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)
    i = (length - 1 - 1) / 2
    while i >= 0:
        sift_down(i, length - 1)
        i -= 1
    # 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
    i = length - 1
    while i > 0:
        nums[0], nums[i] = nums[i], nums[0]
        sift_down(0, i - 1)
        i -= 1
    return nums
```

## 希尔排序
```Python3
def shell_sort(nums):
    length = len(nums)
    h = 1
    while h < length / 3:
        h = int(3 * h + 1)
    while h >= 1:
        for i in range(h, length):
            j = i
            while j >= h and nums[j] < nums[j - h]:
                nums[j], nums[j - h] = nums[j - h], nums[j]
                j -= h
        h = int(h / 3)
    return nums
```

## 桶排序
```Python3
def bucket_sort(nums):
    min_num = min(nums)
    max_num = max(nums)
    # 桶的大小
    bucket_range = (max_num-min_num) / len(nums)
    # 桶数组
    count_list = [[] for i in range(len(nums) + 1)]
    # 向桶数组填数
    for i in nums:
        count_list[int((i-min_num)//bucket_range)].append(i)
    nums.clear()
    # 回填，这里桶内部排序直接调用了sorted
    for i in count_list:
        for j in sorted(i):
            nums.append(j)
    return nums
```



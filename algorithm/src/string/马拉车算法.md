```Python3
def manacher(s):
    # 马拉车算法
    n = len(s)
    arm = [0] * n
    l, r = 0, -1
    for i in range(0, n):
        k = 1 if i > r else min(arm[l + r - i], r - i + 1)
        
        # 持续增加回文串的长度
        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
            k += 1
        arm[i] = k
        
        # 更新右侧最远的回文串边界
        k -= 1
        if i + k > r:
            l = i - k
            r = i + k
    # 返回每个位置往右的臂长
    return arm

作者：liupengsay
链接：https://leetcode.cn/problems/longest-palindromic-substring/solution/by-liupengsay-6udq/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```Python3
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def manacher(s):
            # 马拉车算法
            n = len(s)
            arm = [0] * n
            l, r = 0, -1
            for i in range(0, n):
                k = 1 if i > r else min(arm[l + r - i], r - i + 1)

                # 持续增加回文串的长度
                while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
                    k += 1
                arm[i] = k

                # 更新右侧最远的回文串边界
                k -= 1
                if i + k > r:
                    l = i - k
                    r = i + k
            # 返回每个位置往右的臂长
            return arm
        s = "#" + "#".join(list(s))+"#"
        dp = manacher(s)
        i = dp.index(max(dp))
        return s[i-dp[i]+1: i+dp[i]].replace("#", "")
```
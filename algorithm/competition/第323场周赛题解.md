# [【儿须成名酒须醉】第323场力扣周赛题解]
***

### 写在前面
我是一只小小小菜鸟，怎么飞也飞也飞不高~
> 最好的结构是数组，最好的算法是遍历，最好的读题不能缺少数据范围！


[【儿须成名酒须醉】第323场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-323/
***    
## [题目一: 删除每行中的最大值]
[题目一: 删除每行中的最大值]: https://leetcode.cn/contest/weekly-contest-323/problems/delete-greatest-value-in-each-row/

### 解题思路
根据题意暴力模拟即可，对于T1暴力就是yyds！
- 暴力
- 模拟
### 代码
```python3
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        ans = 0
        m, n = len(grid), len(grid[0])
        for _ in range(n):
            cur = 0
            for i in range(m):
                val = max(grid[i])
                cur = cur if cur > val else val
                # 熟悉API是多么重要
                grid[i].remove(val)
            ans += cur
        return ans
```
### 复杂度分析
- 时间复杂度$O(mn^{2})$
- 空间复杂度$O(1)$

***
## [题目二：数组中最长的方波]

[题目二：数组中最长的方波]: https://leetcode.cn/contest/weekly-contest-323/problems/longest-square-streak-in-an-array/
### 解题思路
方波子序列不要求连续且可排序，由于数据范围有限方波子序列最多不超过$17(2^17>10^5)$，可以直接用暴力比较哈希表递增判断，也可以排序后进行预处理
- 哈希
- 暴力
- 排序
### 代码
```python3
class Solution:
    def longestSquareStreak(self, nums: List[int]) -> int:
        dct = sorted(list(set(nums)), reverse=True)
        pre = defaultdict(int)
        ans = 0
        for num in dct:
            pre[num] = pre[num * num] + 1
            ans = ans if ans > pre[num] else pre[num]
        return ans if ans > 1 else -1
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$


***
## [题目三：设计内存分配器]

[题目三：设计内存分配器]: https://leetcode.cn/contest/weekly-contest-323/problems/design-memory-allocator/
### 解题思路
数据范围的重要性，就像是不同复杂度的算法一样天差地别，直接暴力走起
- 暴力
- 模拟

### 代码
```python3
class Allocator:

    def __init__(self, n: int):
        self.lst = [-1] * n
        self.n = n

    def allocate(self, size: int, mID: int) -> int:
        pre = 0
        for i in range(self.n):
            if self.lst[i] == -1:
                pre += 1
            else:
                pre = 0
            if pre == size:
                self.lst[i - pre + 1:i + 1] = [mID] * size
                return i - pre + 1
        return -1

    def free(self, mID: int) -> int:
        ans = 0
        for i in range(self.n):
            if self.lst[i] == mID:
                ans += 1
                self.lst[i] = -1
        return ans
```
### 复杂度分析
设内存数组大小为$n$，调用总次数为$m$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(n)$

***
## [题目四：矩阵查询可获得的最大分数]

[题目四：矩阵查询可获得的最大分数]: https://leetcode.cn/contest/weekly-contest-323/problems/maximum-number-of-points-from-grid-queries/
### 解题思路
一看到这种具有大小关系的查询，直接就是经典的并查集加离线算法套路，力扣上有很多类似的题目
- 并查集
- 离线算法
- 广度优先搜索

### 代码
```python3
# 标准并查集
class UnionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1] * n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def get_root_part(self):
        # 获取每个根节点对应的组
        part = defaultdict(list)
        n = len(self.root)
        for i in range(n):
            part[self.find(i)].append(i)
        return part

    def get_root_size(self):
        # 获取每个根节点对应的组大小
        size = defaultdict(int)
        n = len(self.root)
        for i in range(n):
            size[self.find(i)] = self.size[self.find(i)]
        return size


class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:

        # 根据邻居关系进行建图处理
        dct = []
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if i + 1 < m:
                    x, y = grid[i][j], grid[i + 1][j]
                    dct.append([i * n + j, i * n + n + j, x if x > y else y])
                if j + 1 < n:
                    x, y = grid[i][j], grid[i][j + 1]
                    dct.append([i * n + j, i * n + 1 + j, x if x > y else y])
        dct.sort(key=lambda d: d[2])
        src = grid[0][0]
        del grid
        uf = UnionFind(m * n)

        # 按照查询值的大小排序，依次进行查询
        k = len(queries)
        ind = list(range(k))
        ind.sort(key=lambda d: queries[d])

        # 根据查询值的大小利用指针持续更新并查集
        ans = []
        j = 0
        length = len(dct)
        for i in ind:
            cur = queries[i]
            while j < length and dct[j][2] < cur:
                uf.union(dct[j][0], dct[j][1])
                j += 1
            if cur > src:
                ans.append([i, uf.size[uf.find(0)]])
            else:
                ans.append([i, 0])
        ans.sort(key=lambda a: a[0])
        return [a[1] for a in ans]
```


### 复杂度分析n
设矩阵的行列数分别为$m$和$n$，查询长度为$k$，则有
- 时间复杂度$O(mnlogmn+klogk)$
- 空间复杂度$O(mn+k)$
***

### 写在最后
谢谢阅读，继续努力！
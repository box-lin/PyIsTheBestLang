# [【儿须成名酒须醉】第86场力扣夜喵双周赛题解]
***
### 写在前面
双周赛刷新最佳排名，进制的知识点不太熟卡在了T2...

[【儿须成名酒须醉】第86场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-86/
***    
## [题目一: 和相等的子数组]


[题目一: 和相等的子数组]: https://leetcode.cn/contest/biweekly-contest-86/problems/find-subarrays-with-equal-sum/
### 解题思路
遍历数组，使用哈希记录出现过的子数组和，如果遇到出现的则直接返回$True$，遍历完也没有重复的则返回$False$
- 哈希
- 遍历
### 代码
```python3
class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
        n = len(nums)
        pre = set()
        for i in range(n - 1):
            if nums[i] + nums[i + 1] in pre:
                return True
            pre.add(nums[i] + nums[i + 1])
        return False
```

### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目二：严格回文的数字]

[题目二：严格回文的数字]: https://leetcode.cn/contest/biweekly-contest-86/problems/strictly-palindromic-number/
### 解题思路
遍历$2$到$n-2$，计算对应进制下$n$的表示，判断其是否都为回文串即可，临时想出来的进制判断算法，居然没有出问题也是很幸运
- 数学
- 进制
### 代码
```python3
class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        
        # 递归获取cur的num进制下的表达
        def check(cur, num):
            if cur <= 1:
                return [[0, cur]]
            cnt = 0
            while cur:
                cur //= num
                cnt += 1
            return [[cnt, 1]] + check(cur - num**cnt)

        for b in range(2, n - 1):
            lst = check(n, b)
            # 利用进制结果判断其是否为回文序列
            tmp = [0] * (lst[0][0] + 1)
            for i, val in lst:
                tmp[-i - 1] = val
            if tmp[::-1] != tmp:
                return False
        return True
```
### 复杂度分析
设需要判断的数字为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(logn)$

***
## [题目三：被列覆盖的最多行数]

[题目三：被列覆盖的最多行数]: https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-rows-covered-by-columns/
### 解题思路
由于数据规模比较小，预先存好每行为$1$的列号，直接采用暴力枚举的方式进行判断即可，Python3有库函数combinations可直接进行枚举
- 枚举
- 组合
### 代码
```python3
from itertools import combinations


class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        m, n = len(mat), len(mat[0])
        # 预先存好对应的列号
        row = [set() for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if mat[i][j]:
                    row[i].add(j)

        ans = 0
        # 枚举组合
        for item in combinations(list(range(n)), cols):
            cur = set(list(item))
            cnt = 0
            for i in range(m):
                if len(row[i].intersection(cur)) == len(row[i]):
                    cnt += 1
            if cnt > ans:
                ans = cnt
        return ans
```
### 复杂度分析
设矩阵的行数与列数分别为$m$和$n$，选取的列数为$k$，则有
- 时间复杂度$O(mnC_n^k)$
- 空间复杂度$O(mn)$
***
## [题目四：预算内的最多机器人数目]

[题目四：预算内的最多机器人数目]: https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-number-of-robots-within-budget/
### 解题思路
使用二分查找符合条件的最大长度，参考经典题目[滑动窗口最大值]使用单调队列的滑动窗口，记录充电时间最大值与对应的运行时间判断是否存在不超过预算的连续子序列即可，附带说一句，Python3的list的pop(0)巨慢，很可能通不过，建议使用deque

[滑动窗口最大值]: https://leetcode.cn/problems/sliding-window-maximum/solution/by-liupengsay-ws1v/
- 二分查找
- 单调队列
- 滑动窗口
### 代码
```python3
from collections import deque


class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:

        def check(k):
            stack = deque()
            add = 0
            for i in range(n):
                # 按照值的大小右端出队
                while stack and stack[-1][1] <= chargeTimes[i]:
                    stack.pop()
                stack.append([i, chargeTimes[i]])
                # 按照索引的范围左端出队
                while stack and stack[0][0] <= i - k:
                    stack.popleft()
                add += runningCosts[i]
                if i >= k:
                    add -= runningCosts[i - k]
                if i >= k - 1 and stack[0][1] + k * add <= budget:
                    return True
            return False

        n = len(chargeTimes)
        low = 0
        high = n
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low
```
### 复杂度分析
设机器人个数为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***
### 写在最后
谢谢阅读，继续努力
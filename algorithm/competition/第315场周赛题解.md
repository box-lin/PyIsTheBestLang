# [【儿须成名酒须醉】第315场力扣周赛题解]
***

### 写在前面
不知道是不是史上最简单的手速场，但是我卡在T4打得太烂了2333

[【儿须成名酒须醉】第315场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-315/
***    
## [题目一: 处理用时最长的那个任务的员工]


[题目一: 处理用时最长的那个任务的员工]: https://leetcode.cn/contest/weekly-contest-314/problems/the-employee-that-worked-on-the-longest-task/
### 解题思路
哈希查看获取最大正数值即可
- 哈希
### 代码
```python3
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        dct = set(nums)
        return max([num for num in dct if num > 0 and -num in dct] + [-1])
```


### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目二：反转之后不同整数的数目]

[题目二：反转之后不同整数的数目]: h
ttps://leetcode.cn/contest/weekly-contest-315/problems/count-number-of-distinct-integers-after-reverse-operations/
### 解题思路
直接模拟操作进行数值反转并加入哈希计算不同元素个数
- 模拟

### 代码
```python3
class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        pre = set(nums)
        for num in nums:
            pre.add(int(str(num)[::-1]))
        return len(pre)
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：反转之后的数字和]

[题目三：反转之后的数字和]: https://leetcode.cn/contest/weekly-contest-315/problems/sum-of-number-and-its-reverse/
### 解题思路
与第二题联动，数据范围有限直接进行枚举即可
- 枚举
- 哈希
- 脑筋急转弯

### 代码
```python3
pre = set()
for num in range(10**5 + 1):
    pre.add(num + int(str(num)[::-1]))

class Solution:
    def sumOfNumberAndReverse(self, num: int) -> bool:
        return num in pre
```
### 复杂度分析
设需要判断的数据最大值为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目四：统计定界子数组的数目]

[题目四：统计定界子数组的数目]: https://leetcode.cn/contest/weekly-contest-315/problems/count-subarrays-with-fixed-bounds/
### 解题思路
经典双指针升级三指针写法，遍历数组枚举子数组开头、最早的结尾与最晚允许的结尾
- 双指针
- 哈希计数
### 代码
```python3
class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        ans = 0
        # 特殊情况直接遍历计数
        if minK == maxK:
            cnt = 0
            for num in nums:
                if num == minK:
                    cnt += 1
                else:
                    ans += cnt * (cnt + 1) // 2
                    cnt = 0
            ans += cnt * (cnt + 1) // 2
            return ans

        # 按照区间范围进行转换
        n = len(nums)
        for i in range(n):
            num = nums[i]
            if minK < num < maxK:
                nums[i] = 1
            elif num == minK:
                nums[i] = 0
            elif num == maxK:
                nums[i] = 2
            else:
                nums[i] = -1

        # 三指针枚举数组开头索引
        j1 = j2 = 0
        cnt1 = defaultdict(int)
        cnt2 = defaultdict(int)
        for i in range(n):

            # 初始化
            if j1 < i:
                j1 = i
                cnt1 = defaultdict(int)
            if j2 < i:
                j2 = i
                cnt2 = defaultdict(int)

            # 尽可能到达最右边
            while j1 < n and nums[j1] != -1:
                cnt1[nums[j1]] += 1
                j1 += 1

            # 遇到首次存在最大值与最小值即停止
            while j2 < n and nums[j2] != -1 and not (cnt2[0] and cnt2[2]):
                cnt2[nums[j2]] += 1
                j2 += 1
            
            # 符合要求的计数加入结果
            if cnt2[0] and cnt2[2]:
                ans += j1 - j2 + 1
            
            if nums[i] != -1:
                cnt1[nums[i]] -= 1
                cnt2[nums[i]] -= 1
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$
***

### 写在最后
谢谢阅读，继续努力！
# [【儿须成名酒须醉】第324场力扣周赛题解]
***

### 写在前面
> 分类讨论什么的，真的是不擅长的呢！


[【儿须成名酒须醉】第324场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-324/
***    
## [题目一: 统计相似字符串对的数目]
[题目一: 统计相似字符串对的数目]: https://leetcode.cn/contest/weekly-contest-324/problems/count-pairs-of-similar-strings/

### 解题思路
根据题意暴力模拟即可，对于T1暴力就是yyds！写题解的时候这里使用了状态压缩，和前缀哈希计数~
- 暴力
- 模拟
### 代码
```python3
class Solution:
    def similarPairs(self, words: List[str]) -> int:
        n = len(words)
        ans = 0
        pre = defaultdict(int)
        for word in words:
            state = 0
            for w in set(word):
                state |= (1 << (ord(w) - ord("a")))
            ans += pre[state]
            pre[state] += 1
        return ans
```
### 复杂度分析
设数组长度为$n$，单词长度为$m$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(n)$

***
## [题目二：使用质因数之和替换后可以取到的最小值]

[题目二：使用质因数之和替换后可以取到的最小值]: https://leetcode.cn/contest/weekly-contest-324/problems/smallest-value-after-replacing-with-sum-of-prime-factors/
### 解题思路
可以证明，每次分解$n$一定会变得更小，所以根据题意进行模拟即可，考点在于质因数分解，做题才发现质因数分解板子有问题的说~
- 质因数分解
- 模拟

### 代码
```python3
def get_prime_factor(num):
    res = []
    for i in range(2, int(math.sqrt(num)) + 1):
        cnt = 0
        while num % i == 0:
            num //= i
            cnt += 1
        if cnt:
            res.append([i, cnt])
        if i > num:
            break
    if num != 1 or not res:
        res.append([num, 1])
    return res


class Solution:
    def smallestValue(self, n: int) -> int:
        while True:
            res = get_prime_factor(n)
            nex = 0
            for num, va in res:
                nex += num*va
            # 坑点，如果不会再变化则停止分解
            if nex == n:
                break
            n = nex
        return n
```
### 复杂度分析
不太会算，给出一个上限
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$


***
## [题目三：添加边使所有节点度数都为偶数]

[题目三：添加边使所有节点度数都为偶数]: https://leetcode.cn/contest/weekly-contest-324/problems/add-edges-to-make-degrees-of-all-nodes-even/
### 解题思路
难点在于分类讨论，以及对图论的熟悉度，要求没有重边和自环，且不关心是否连通，由此根据节点度数为奇数进行情况分类~
- 分类讨论
- 模拟

### 代码
```python3
class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        degree = [0] * n
        edge = set()
        for a, b in edges:
            a -= 1
            b -= 1
            # 将无向边进行序号排序存储
            if a > b:
                a, b = b, a
            degree[a] += 1
            degree[b] += 1
            edge.add((a, b))

        odd = [i for i in range(n) if degree[i] % 2 == 1]
        # odd 长度只能为偶数，分0、2、4和大于4讨论
        if len(odd) > 4:
            # 最多两条显然不行
            return False

        elif len(odd) == 0:
            # 没有奇数度的点，直接满足
            return True

        elif len(odd) == 2:
            # 有两个点为奇数度
            i, j = odd
            if (i, j) not in edge:
                # 直连 (i,j)
                return True
            for x in range(n):
                if i != x and j != x:
                    if tuple(sorted([i, x])) not in edge and tuple(sorted([j, x])) not in edge:
                        # 连 (i,x)和 (x,j)
                        return True
            return False
        
        elif len(odd) == 4:
            for item in permutations(odd, 4):
                # 4个奇数度的点时枚举两条边的连法并判断是否可行
                x, y, a, b = item
                if x > y:
                    x, y = y, x
                if a > b:
                    a, b = b, a
                if (x, y) in edge or (a, b) in edge:
                    continue
                dct = defaultdict(int)
                for i in item:
                    dct[i] += 1
                if all((degree[i] + dct[i]) % 2 == 0 for i in odd):
                    return True
        return False
```
### 复杂度分析
设节点个数为$n$，边条数为$m$，则有
- 时间复杂度$O(m+n)$
- 空间复杂度$O(n)$

***
## [题目四：查询树中环的长度]

[题目四：查询树中环的长度]: https://leetcode.cn/contest/weekly-contest-324/problems/cycle-length-queries-in-a-tree/
### 解题思路
可以发现，环的长度就是两个节点以及他们到最近的公共祖先之间一起组成的路径长度，由于是完全二叉树，因此通过编号进行祖先节点求取~
- LCA最近公共祖先
- 倍增思想
- 模拟
### 代码
```python3
class Solution:
    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        ans = []
        for a, b in queries:
            # 先找到节点b的祖先链条
            ans_b = [b]
            while b > 1:
                ans_b.append(b // 2)
                b //= 2
            if ans_b[-1] != b:
                ans_b.append(b)
            ind_b = {num: i for i, num in enumerate(ans_b)}
            
            # 寻找a与b的最近祖先位置
            ans_a = [a]
            while ans_a[-1] not in ind_b:
                ans_a.append(a // 2)
                a //= 2
            # 节点a和节点b到祖先节点的环长度
            ans.append(len(ans_a) + ind_b[ans_a[-1]])
        return ans
```


### 复杂度分析
- 时间复杂度$O(mn)$
- 空间复杂度$O(m)$
***

### 写在最后
谢谢阅读，继续努力！
# [【儿须成名酒须醉】第318场力扣周赛题解]
***

### 写在前面
动态规划！动态规划！边界！转移！条件！

[【儿须成名酒须醉】第318场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-318/
***    
## [题目一: 对数组执行操作]
[题目一: 对数组执行操作]: https://leetcode.cn/contest/weekly-contest-318/problems/apply-operations-to-an-array/

### 解题思路
读懂题意，依次有序执行，直接模拟即可！
- 模拟
### 代码
```python3
class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        n = len(nums)
        for i in range(n - 1):
            if nums[i] == nums[i + 1]:
                nums[i] *= 2
                nums[i + 1] = 0
        return [num for num in nums if num != 0] + [num for num in nums if num == 0]
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目二：长度为 K 子数组中的最大和]

[题目二：长度为 K 子数组中的最大和]: https://leetcode.cn/contest/weekly-contest-318/problems/maximum-sum-of-distinct-subarrays-with-length-k/
### 解题思路
滑动窗口查看每一个长度为k的数组，使用哈希记录数的个数判断是否满足要求即可！
- 滑动窗口
- 哈希
### 代码
```python3
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        ans = cur = 0
        pre = dict()
        n = len(nums)
        for i in range(n):
            pre[nums[i]] = pre.get(nums[i], 0) + 1
            cur += nums[i]
            if len(pre) == k:
                ans = max(ans, cur)
            if i >= k - 1:
                cur -= nums[i - k + 1]
                pre[nums[i - k + 1]] -= 1
                if not pre[nums[i - k + 1]]:
                    del pre[nums[i - k + 1]]
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：雇佣 K 位工人的总代价]

[题目三：雇佣 K 位工人的总代价]: https://leetcode.cn/contest/weekly-contest-318/problems/total-cost-to-hire-k-workers/
### 解题思路
使用两个优先队列分别记录前面的candidates个和后面candidates个候选人与代价，每轮选取其中较小的，使用访问数组记录每一轮选择过的人！
- 贪心
- 优先队列

### 代码
```python3
class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        visit = [0] * n
        ans, pre_ind, post_ind = 0, -1, n
        pre_stack = []
        post_stack = []
        for _ in range(k):
            
            # 更新前面候选人队列
            while pre_stack and visit[pre_stack[0][1]]:
                heapq.heappop(pre_stack)  # 已使用
            while pre_ind + 1 < n and len(pre_stack) < candidates:
                pre_ind += 1
                if visit[pre_ind]:  # 已使用
                    continue
                heapq.heappush(pre_stack, [costs[pre_ind], pre_ind])

            # 更新后面候选人队列
            while post_stack and visit[post_stack[0][1]]:
                heapq.heappop(post_stack)  # 已使用
            while post_ind - 1 >= 0 and len(post_stack) < candidates:
                post_ind -= 1
                if visit[post_ind]:  # 已使用
                    continue
                heapq.heappush(post_stack, [costs[post_ind], post_ind])
            
            # 选择候选人
            if not post_stack or (pre_stack and post_stack and pre_stack[0] <= post_stack[0]):
                num, i = heapq.heappop(pre_stack)
                ans += num
                visit[i] = 1
            else:
                num, i = heapq.heappop(post_stack)
                ans += num
                visit[i] = 1
        return ans
```
### 复杂度分析
设数组长度为$n$，选择人数为$k$，候选人个数为$C$，则有
- 时间复杂度$O(kClogC+n)$
- 空间复杂度$O(n)$

***
## [题目四：最小移动总距离]

[题目四：最小移动总距离]: https://leetcode.cn/contest/weekly-contest-318/problems/minimum-total-distance-traveled/
### 解题思路
动态规划的做法，类似背包DP，位置都排序后遍历工厂的维修上限，计算$dp[i][j]$表示前i个工厂维修前j个机器人的最短移动距离，计算距离时，可使用二分查找与前缀和做处理！
- 动态规划
- 前缀和
- 二分查找

### 代码
```python3
class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:

        robot.sort()
        factory.sort()

        # 计算前缀和
        n = len(robot)
        pre_sum = [0] * (n + 1)
        for i in range(n):
            pre_sum[i + 1] = pre_sum[i] + robot[i]

        # 计算工厂与需要维修的机器人之间的总距离
        def check():
            if pos <= robot[x]:
                return pre_sum[y + 1] - pre_sum[x] - (y - x + 1) * pos
            if pos >= robot[y]:
                return -(pre_sum[y + 1] - pre_sum[x] - (y - x + 1) * pos)
            # 二分查找工厂位置，计算左右两边机器人的距离总和
            p = bisect.bisect_right(robot, pos)
            left = (p - x) * pos - (pre_sum[p] - pre_sum[x])  # [x, p-1]
            right = pre_sum[y + 1] - pre_sum[p] - (y - p + 1) * pos  # [p, y]
            return left + right

        # 动态规划pre[k]表示维修前k个机器人所需要的代价
        pre = defaultdict(lambda: float("inf"))
        pre[0] = 0
        for pos, limit in factory:
            cur = pre.copy()
            for x in list(pre.keys()):
                # 遍历当前维修机器人的数量
                for k in range(1, limit + 1):
                    y = x + k - 1
                    if y < n:
                        cost = check()
                        cur[x + k] = min(cur[x + k], pre[x + k], cost + pre[x])
                    else:
                        break
            pre = cur.copy()
        return pre[n]
```
### 复杂度分析
设工厂数为$m$，机器人个数为$n$，维修上限为$k$，则有
- 时间复杂度$O(mnklogn)$
- 空间复杂度$O(mk)$

### 优化
使用背包DP直接计算$dp[i][j]$，这才是最直观正确的做法！

```python3
class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        robot.sort()
        factory.sort()
        m, n = len(factory), len(robot)
        dp = [[float("inf")]*(n+1) for _ in range(m+1)]
        dp[0][0] = 0
        for i in range(m):
            for j in range(n+1):
                if dp[i][j] < float("inf"):
                    # 前序维修j台即robot[0:j-1]
                    dp[i+1][j] = min(dp[i+1][j], dp[i][j])
                    cost = 0
                    for k in range(1, factory[i][1]+1):
                        # 当前维修k台到j+k-1即robot[j:j+k]
                        if j+k-1<n:
                            cost += abs(factory[i][0]-robot[j+k-1])
                            dp[i+1][j+k] = min(dp[i+1][j+k], dp[i][j]+cost)
                        else:
                            break
        return dp[-1][-1]
```
### 复杂度分析
设工厂数为$m$，机器人个数为$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$
***

### 写在最后
谢谢阅读，继续努力！
# [【儿须成名酒须醉】第309场力扣周赛题解]
***
### 写在前面
卡在了T1没认真读题，T3对位运算不熟练想了几次错误的弯路

[【儿须成名酒须醉】第309场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-309

***    
## [题目一: 检查相同字母间的距离]

[题目一: 检查相同字母间的距离]: https://leetcode.cn/contest/weekly-contest-309/problems/check-distances-between-same-letters/
### 解题思路
使用哈希记录前序的字母索引，判断其距离与给出的是否相等即可，注意不需要比较整个距离数组
- 哈希
- 遍历
### 代码
```python3
class Solution:
    def checkDistances(self, s: str, distance: List[int]) -> bool:
        n = len(s)
        pre = dict()
        for i in range(n):
            if s[i] in pre:
                if distance[ord(s[i]) - ord('a')] != i - pre[s[i]] - 1:
                    return False
            else:
                pre[s[i]] = i
        return True
```

### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

### 题目感想
读清题意是多么重要，还以为自己时遇到了鬼打墙怎么这么简单的都不会
***
## [题目二：恰好移动 k 步到达某一位置的方法数目]

[题目二：恰好移动 k 步到达某一位置的方法数目]: https://leetcode.cn/contest/weekly-contest-309/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/
### 解题思路
使用广度优先搜索模拟每一步移动，使用哈希记录每个位置方案数
- 模拟
- 广度优先搜索
### 代码
```python3
from collections import defaultdict


MOD = 10**9 + 7


class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        pre = defaultdict()
        pre[startPos] = 1
        while k:
            nex = defaultdict()
            for pos in pre:
                # 更新往左与往右的方案数
                nex[pos + 1] += pre[pos]
                nex[pos - 1] += pre[pos]
            for pos in nex:
                nex[pos] %= MOD
            pre = nex
            k -= 1
        return pre[endPos] % MOD
```
### 复杂度分析
设移动次数为$k$，则有
- 时间复杂度$O(k^2)$
- 空间复杂度$O(k)$
### 题目感想
第一想法以为是floyd的解法，发现数组没办法进行迭代更新，才想到用哈希的办法
***
## [题目三：最长优雅子数组]

[题目三：最长优雅子数组]: https://leetcode.cn/contest/weekly-contest-309/problems/longest-nice-subarray/
### 解题思路
连续子数组内任意数对取与为零的充要条件就是所有数取异或的值等于它们的和，因此采用双指针维护最大区间即可
- 双指针
- 位远算
### 代码
```python3
class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        cur = 0
        ans = 1
        j = 0
        for i in range(n):
            while j < n and cur ^ nums[j] == cur + nums[j]:
                cur ^= nums[j]
                j += 1
            if j - i > ans:
                ans = j - i
            cur ^= nums[i]
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$
### 题目感想
第一时间想到了异或的特点，但是始终没往双指针方面想，总想着用前缀异或与哈希太无语
***
## [题目四：会议室 III]

[题目四：会议室 III]: https://leetcode.cn/contest/weekly-contest-309/problems/meeting-rooms-iii/
### 解题思路
按照开始时间遍历每一个会议，使用一个堆记录会议室使用情况的开始时间和编号，当前会议开始时间小于会议室的时候就出栈会议室备用，同时使用一个有序集合维护当前可以使用的空闲会议室，每次取最小编号的会议室给当前会议使用
- 模拟
- 有序集合
- 堆（优先队列）
### 代码
```python3
import heapq
from collections import defaultdict
from sortedcontainers import SortedList


class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        meetings.sort(key=lambda x: x[0])
        # 记录会议室使用情况
        stack = []
        heapq.heapify(stack)
        # 记录会议室使用次数
        cnt = defaultdict(int)
        # 记录空闲会议室
        null = SortedList(list(range(n)))
        for start, end in meetings:
            # 结束时间早于当前会议开始时间的出队
            while stack and stack[0][0] < start:
                tm, i = heapq.heappop(stack)
                null.add(i)
            # 有空闲会议室直接使用
            if null:
                i = null.pop(0)
                heapq.heappush(stack, [start + end - start - 1, i])
                cnt[i] += 1
            # 没有空闲等下一个结束时间最早的会议室
            else:
                tm, i = heapq.heappop(stack)
                heapq.heappush(stack, [tm + 1 + end - start - 1, i])
                cnt[i] += 1
        # 判断返回结果
        val = max(cnt.values())
        for i in range(n):
            if cnt[i] == val:
                return i
```
### 复杂度分析
设会议的个数为$m$，会议室个数为$n$，则有
- 时间复杂度$O(mlogmn)$
- 空间复杂度$O(n)$

### 题目感想
这题着急的话是真容易错，尤其测试用例给的很鸡贼很容易测不出来BUG
***
### 写在最后
谢谢阅读，继续努力

# [【儿须成名酒须醉】第91场力扣夜喵双周赛题解]
***

### 写在前面
空杯心态心态心态心态心态心态心态心态心态，笑看竞赛分起起伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏伏！
![image.png](https://pic.leetcode.cn/1668268538-ejKIxl-image.png)


[【儿须成名酒须醉】第91场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-91/
***    
## [题目一: 不同的平均值数目]


[题目一: 不同的平均值数目]: https://leetcode.cn/contest/biweekly-contest-91/problems/number-of-distinct-averages/
### 解题思路
排序后模拟，计算每轮第一个数即最小值与最后一个数即最大值计算平均值，可以用加和代替，并不需要真实的移除数字，使用对应的索引进行计算即可
- 排序
- 模拟
### 代码
```python3
class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        return len(set(nums[i] + nums[n - 1 - i] for i in range(n // 2)))
```

### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***
## [题目二：统计构造好字符串的方案数]

[题目二：统计构造好字符串的方案数]: https://leetcode.cn/contest/biweekly-contest-91/problems/count-ways-to-build-good-strings/
### 解题思路
背包DP的做法，设长度为$i$的方案数有$dp[i]$种，则有$dp[i]=dp[i-one]+dp[i-zero]$，注意初始值$dp[0]=1$与边界$i>=zero$与$i>=one$，最后的结果即为$sum(dp[low:high+1])$
- 动态规划
- 背包DP
- 模拟
### 代码
```python3
MOD = 10**9 + 7


class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0] * (high + 1)
        dp[0] = 1
        for i in range(1, high + 1):
            if i - zero >= 0:
                dp[i] += dp[i - zero]
            if i - one >= 0:
                dp[i] += dp[i - one]
            dp[i] %= MOD
        return sum(dp[low: high+1]) % MOD
```
### 复杂度分析
设字符串上界为$high$，则有
- 时间复杂度$O(high)$
- 空间复杂度$O(high)$

***
## [题目三：树上最大得分和路径]

[题目三：树上最大得分和路径]: https://leetcode.cn/contest/biweekly-contest-91/problems/most-profitable-path-in-a-tree/

### 解题思路
首先使用dfs序的方式，记录bob到节点0的时间戳，再回溯枚举alice到叶子节点的所有路径，按照bob是否到达路径对应节点进行得分计算，取最大值
- 深度优先搜索
- 枚举
- 回溯
### 代码
```python3
class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        
        def find_bob(i):
            visit[i] = 1
            if i == bob:
                return [bob]
            res = []
            for j in dct[i]:
                if not visit[j]:
                    cur = find_bob(j)
                    if cur:
                        return [i] + cur
            return res
        
        def find_alice(i):
            visit[i] = 1
            nonlocal ans, pre, time

            # 判断当前节点alice的得分
            if i not in dis or dis[i] > time:
                x = amount[i]  # alice先到达
            elif i in dis and dis[i] == time:
                x = amount[i] // 2  # 同时到达
            else:
                x = 0  # bob先到达

            # 增加alice当前得分与时间戳
            pre += x
            time += 1
            is_leaf = True
            for j in dct[i]:
                if not visit[j]:
                    find_alice(j)
                    is_leaf = False
            if is_leaf:
                # 如果是叶子节点则进行得分更新
                ans = ans if ans > pre else pre
            pre -= x
            time -= 1
            return
        
        # 第一段：存图
        n = len(amount)
        dct = [[] for _ in range(n)]
        for a, b in edges:
            dct[a].append(b)
            dct[b].append(a)

        # 第二段：深搜查询bob到根节点的路径
        visit = [0] * n
        path = find_bob(0)
        # 将对应节点用bob的时间戳标记
        m = len(path)
        dis = {path[i]: m - 1 - i for i in range(m)}

        # 第三段：使用回溯枚举alice的每一条路径得分并取最大值
        visit = [0] * n
        ans = float("-inf")
        pre = time = 0
        find_alice(0)
        return ans

```
### 复杂度分析
设无向树的节点为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
## [题目四：根据限制分割消息]

[题目四：根据限制分割消息]: https://leetcode.cn/contest/biweekly-contest-91/problems/split-message-based-on-limit/
### 解题思路
根据结果要求的字符串数组单项长度以及总体长度，进行不等式生成后枚举可行的解，设字符串长度为$n$，最短的可分为$b$个部分，则有
- 枚举
- 模拟
- 指针
- 数学
>每个部分至少有一个字符串中的字符，即有$1<=b<=n$
>每个部分可分为四个部分，则有
> >第一部分为原来的字符串组成，总长度为$n$
> > 第二部分为每个部分的子编号$a$组成，为$1$到$b$的正整数，设总长度为$pre$
> >第三部分为每个部分的编号总个数$b$组成，有$b$个，设$b$的数字位数为$post$, 则总长度为$post*b$
> >第四部分为每个部分的特殊边界字符组成即"</>"，总长度为$b*3$
> >设结果字符串数组总长度为$total$，则有$total=pre + b * post + b * 3 + n$
> >此外，除了最后一个字符可以小于等于$limit$之外，前面$b-1$个字符都要等于$limit$，因此有
$$(b - 1) * limit + post * 2 + 3 <= total <= b * limit$$
> 由此从小到大进行$b$的值枚举，判断是否符合要求
> 对于符合要求的$b$的最小值，使用指针的方式模拟进行结果生成
### 代码
```python3
def check(num):
    # 计算[1..num]范围内所有正整数的数字位数个数
    pre = 0
    for i in range(1, 11):
        if num >= 10 ** i:  # i+1位数的最小值
            # 说明i位数的所有数字都小于num即num至少为i+1位数
            pre += (10 ** i - 10 ** (i - 1)) * i  # i位数的字符数
        else:
            # 说明num位i位数同时计算i位数里面小于等于num的数字的字符数
            pre += (num - 10 ** (i - 1) + 1) * len(str(num))
            break
    return pre


class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        ind = -1
        # 枚举b的取值
        for b in range(1, n + 1):
            pre = check(b)
            post = len(str(b))
            # 如果符合要求则停止遍历
            if (b - 1) * limit + post * 2 + 3 < pre + b * post + b * 3 + n <= b * limit:
                # 所得结果即为最短的数组
                ind = b
                break
        if ind == -1:
            return []

        # 遍历编号使用指针进行结果生成
        i = 0
        res = []
        for x in range(1, ind + 1):
            st = f"<{x}/{ind}>"
            m = limit - len(st)
            res.append(message[i:i + m] + st)
            i += m
        return res
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***
### 写在最后
再接再厉，明日再战！
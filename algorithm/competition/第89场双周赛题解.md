# [【儿须成名酒须醉】第89场力扣夜喵双周赛题解]
***

### 写在前面
费尽心力AK，不过是不掉分罢了2333


[【儿须成名酒须醉】第89场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-89/
***    
## [题目一: 有效时间的数目]


[题目一: 有效时间的数目]: https://leetcode.cn/contest/biweekly-contest-89/problems/number-of-valid-clock-times/
### 解题思路
不多说，T1就是要暴力才对！
- 枚举
- 暴力
### 代码
```python3
class Solution:
    def countTime(self, time: str) -> int:

        def check(st):
            # 判断是否成立
            for x in [0, 1, 3, 4]:
                if time[x] == "?" or time[x] == st[x]:
                    continue
                else:
                    return False
            return True
        
        # 枚举所有时间点
        ans = 0
        for i in range(24):
            for j in range(60):
                h = str(i)
                h = (2 - len(h)) * "0" + h
                m = str(j)
                m = (2 - len(m)) * "0" + m
                ans += check(f"{h}:{m}")
        return ans
```

### 复杂度分析
设小时数为$m$，分钟数为$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(1)$
***
## [题目二：二的幂数组中查询范围内的乘积]

[题目二：二的幂数组中查询范围内的乘积]: https://leetcode.cn/contest/biweekly-contest-89/problems/range-product-queries-of-powers/
### 解题思路
使用贪心确定组成n的最少2的幂数字个数即为n的二进制中位数为1对应的数，经典的位运算写法可以求得；预处理前缀积之后，挨个查询即可，若累计乘积过大，可考虑乘法逆元进行处理，本题power数组较短，暴力取模也可。
- 贪心
- 位运算
- 前缀积
- 乘法逆元
### 代码
```python3
MOD = 10 ** 9 + 7


class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        
        # 经典取二进制位1的数
        nums = []
        while n:
            # 最后一个位1代表的数
            nums.append(n & (-n))
            # 去除掉最后一个位1
            n &= (n - 1)
        
        # 计算前缀积
        m = len(nums)
        pre = [1] * (m + 1)
        for i in range(m):
            pre[i + 1] = (pre[i] * nums[i]) % MOD
        
        # 按个查询
        ans = []
        for i, j in queries:
            ans.append(pre[j + 1] * pow(pre[i], -1, MOD) % MOD)
        return ans
```
### 复杂度分析
设查询数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目三：最小化数组中的最大值]

[题目三：最小化数组中的最大值]: https://leetcode.cn/contest/biweekly-contest-89/problems/minimize-maximum-of-array/
### 解题思路
最小化最大值，一开始就应该想到用二分查找的...就是贪心的处理不太好想，倒序进行处理，保证nums[i]小于等于当前分析值的情况下，将nums[i-1]尽可能增大到当前分析值。
- 贪心
- 二分查找
### 代码
```python3
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:

        def check(ceil):
            # 贪心查看可能性
            lst = nums[:]
            for i in range(n - 2, -1, -1):
                if lst[i + 1] > ceil:  # 取有余补不足
                    lst[i] += lst[i + 1] - ceil
                    lst[i + 1] = ceil
                if lst[i] < ceil:  # 取取有余补不足
                    add = ceil - lst[i] if ceil - lst[i] < lst[i + 1] else lst[i + 1]
                    lst[i] += add
                if lst[i + 1] > ceil:
                    return False
            return lst[0] <= ceil

        # 确定上下界进行二分
        n = len(nums)
        low = 0
        high = max(nums)
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                high = mid
            else:
                low = mid
        return low if check(low) else high
```
### 复杂度分析
设数组的长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***
## [题目四：创建价值相同的连通块]

[题目四：创建价值相同的连通块]: https://leetcode.cn/contest/biweekly-contest-89/problems/create-components-with-same-value/
### 解题思路
可以说节点值取值范围为1到50是非常重要的信息，将无向图转换为有向生成树，利用总数和的因子从小到大，即连通块的个数从大到小枚举，最先满足要求的连通块个数减1即为可以删除的最大边数，其中使用树形DP递归判断是否可以形成相应的连通块。
- 图论
- 数论
- 枚举
### 代码
```python3

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:

        def get_all_factor(num):
            factor = set()
            for x in range(1, int(math.sqrt(num)) + 1):
                if num % x == 0:
                    factor.add(x)
                    factor.add(num // x)
            return sorted(list(factor))

        # 使用广搜变成有向生成树
        n = len(nums)
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)
        direction = [[] for _ in range(n)]
        visit = {0}
        stack = [0]
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    if j not in visit:
                        visit.add(j)
                        nex.append(j)
                        direction[i].append(j)
            stack = nex

        def dfs(u):
            part = nums[u]
            for v in direction[u]:
                part += dfs(v)
            if part > target:
                return float("inf")
            if part == target:
                return 0
            return part

        # 分解因子枚举连通块个数
        total = sum(nums)
        factors = get_all_factor(total)
        for target in factors:
            cnt = total // target
            if dfs(0) == 0:
                return cnt - 1
        return 0
```
### 复杂度分析
设节点个数为$n$，总和因子个数为$m$，则有
- 时间复杂度$O(nm)$
- 空间复杂度$O(n)$
***
### 写在最后
谢谢阅读，明日再战！
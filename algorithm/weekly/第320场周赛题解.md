# [【儿须成名酒须醉】第320场力扣周赛题解]
***

### 写在前面
动态规划！动态规划！边界！转移！条件！明明都是老套的题目类型，为什么还是会卡顿！！
![image.png](https://pic.leetcode.cn/1668310410-zYWmav-image.png)

[【儿须成名酒须醉】第320场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-320/
***    
## [题目一: 数组中不等三元组的数目]
[题目一: 数组中不等三元组的数目]: https://leetcode.cn/contest/weekly-contest-320/problems/number-of-unequal-triplets-in-array/

### 解题思路
- 暴力枚举
### 代码
```python3
class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    if len(set([nums[i], nums[j], nums[k]])) == 3:
                        ans += 1
        return ans
```
### 复杂度分析
设数组长度为$n$
- 时间复杂度$O(n^3)$
- 空间复杂度$O(n^3)$
### 优化
```python3
class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        cnt = Counter(nums)
        ans = 0
        for item in combinations(list(cnt.keys()), 3):
            a, b, c = item
            ans += cnt[a]*cnt[b]*cnt[c]
        return ans
```
***
## [题目二：二叉搜索树最近节点查询]

[题目二：二叉搜索树最近节点查询]: https://leetcode.cn/contest/weekly-contest-320/problems/closest-nodes-queries-in-a-binary-search-tree/
### 解题思路
将节点值取出，注意不能使用递归获得返回值会栈溢出！然后使用二分查找进行查询
- 二分查找
### 代码
```python3
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:

        def dfs(node):
            if not node:
                return []
            dfs(node.left)
            lst.append(node.val)
            dfs(node.right)
            return

        # 使用回溯取出二叉树里面的值
        lst = []
        dfs(root)

        # 二分查找符合条件的相应值
        ans = []
        for num in queries:
            cur = [-1, -1]
            i = bisect.bisect_right(lst, num) - 1
            if 0 <= i < len(lst):
                cur[0] = lst[i]

            i = bisect.bisect_left(lst, num)
            if 0 <= i < len(lst):
                cur[1] = lst[i]
            ans.append(cur)
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$


***
## [题目三：到达首都的最少油耗]

[题目三：到达首都的最少油耗]: https://leetcode.cn/contest/weekly-contest-320/problems/minimum-fuel-cost-to-report-to-the-capital/
### 解题思路
典型的树形DP题目，需要理解清楚油耗具体是怎么产生的..例子给的实在暧昧！
- 树形DP

### 代码
```python3
class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:

        def dfs(i):
            visit[i] = 1
            cnt = dis = 0
            for j in dct[i]:
                if not visit[j]:
                    a, b = dfs(j)
                    cnt += a
                    dis += math.ceil(a/seats) + b
            # [到达当前节点的总人数, 到达当前节点的总油耗]
            return [cnt+1, dis]
    

        n = len(roads) + 1
        dct = [[] for _ in range(n)]
        for i, j in roads:
            dct[i].append(j)
            dct[j].append(i)
        visit = [0] * n
        return dfs(0)[1]
```
### 复杂度分析
设节点个数为$n$
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目四：完美分割的方案数]

[题目四：完美分割的方案数]: https://leetcode.cn/contest/weekly-contest-320/problems/number-of-beautiful-partitions/
### 解题思路
使用$dp[i][x]$表示s[i:]往后可以分成$x$段的方案数，枚举$i$开头的子序列可行的结尾$j$，则$dp[i][x]+=dp[j][x-1]$，具体需要预先计算可行的$s[i:j]$进行剪枝
- 动态规划
- 枚举

### 代码
```python3
MOD = 10 ** 9 + 7


class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        n = len(s)
        target = set("2357")
        
        # 预先存好以i开头的子序列有哪些段是可以满足要求的
        nex = [[] for _ in range(n)]
        for i in range(n):
            if s[i] in target:
                for j in range(i + minLength - 1, n):
                    if s[j] not in target and (j + 1 == n or s[j + 1] in target):
                        nex[i].append(j)
        
        # 计算s[i:]往后最多有几个分割点
        post = [0]*n
        for i in range(n-2, -1, -1):
            post[i] = post[i+1] + int(s[i] not in target and s[i+1] in target)
            
        @lru_cache(None)
        def dfs(i, x):
            # 中止
            if i == n:
                return int(x == 0)
            
            # 剪枝
            if s[i] not in target:
                return 0
    
            res = 0
            high = n - (x - 1) * minLength - 1   
            for j in nex[i]:
                if j <= high and post[j] >= x-1:  # 剪枝
                    res += dfs(j + 1, x - 1)
                    res %= MOD
                else:
                    break
            return res

        return dfs(0, k)
```


### 复杂度分析
算不明白，比$O(kn)$高，比$O(kn^{2})$低，设数组长度为$n$，分割成$k$段，则有
- 时间复杂度$O(kn^{1+})$
- 空间复杂度$O(kn^{1+})$
***

### 写在最后
谢谢阅读，继续努力！
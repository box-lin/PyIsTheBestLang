# 【儿须成名酒须醉】力扣[第308场周赛]题解
***
### 写在前面
周赛刷新最佳排名113到28，写下粗浅又不够优雅的题解纪念进了前百

[第308场周赛]: https://leetcode.cn/contest/weekly-contest-308
![第308场周赛排名.png](../picture/第308场周赛排名.png)
***    
## [题目一: 和有限的最长子序列]
### 解题思路
由于都是正数序列越长和越大，同等长度数值越大序列和越大，因此对数组进行排序后使用双指针确定不超过每个目标和的最长子序列
- 双指针
- 排序
- 暴力
### 代码
```python3
class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        
        def check(ceil):
            # 这可以算是一种双指针模板了
            res = 0 # 符合条件的最长子序列长度
            j = 0 # 右指针
            pre = 0 # 前序和
            for i in range(n):
                # 注意右指针始终保持不落后于左指针
                if j < i:
                    j = i
                    pre = 0
                # 移动指针
                while j < n and pre + nums[j] <= ceil:
                    pre += nums[j]
                    j += 1
                # 计算长度
                if j - i > res:
                    res = j - i
                # 减去前缀
                pre -= nums[i]
            return res

        n = len(nums)
        # 排序后挨个查询长度
        nums.sort()
        ans = []
        for target in queries:
            ans.append(check(target))
        return ans
```

### 复杂度分析
设数组长度为$n$，查询个数为$m$，则有
- 时间复杂度$O(n(logn+m))$
- 空间复杂度$O(m)$
### 题目感想
比赛时使用的暴力方法，其实可以对查询数组也进行排序，这样只需要一次遍历，就是写起来预计会麻烦一点，这题目其实应该算是第二题的难度
***
## [题目二：从字符串中移除星号]
### 解题思路
简单的栈模拟题，遍历数组进行消除即可
- 模拟
- 栈
### 代码
```python3
class Solution:
    def removeStars(self, s: str) -> str:
        lst = []
        for va in s:
            if va == '*':
                if lst: # 注意为空的情况
                    lst.pop()
            else:
                lst.append(va)
        return ''.join(lst)
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
### 题目感想
这题目其实应该是第一题的难度
***
## [题目三：收集垃圾的最少总时间]
### 解题思路
本题主要在理解题意，每个垃圾车互不干扰，最后结果为垃圾车收集垃圾以及不同站点间的行驶距离，对于往后没有对应垃圾的垃圾车则不再继续往后行驶，因此采用后缀数组维护一个后面是否还有对应的垃圾，收集到终止点即可
- 后缀数组
- 贪心
### 代码
```python3
class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:

        def check(tp):
            # 后缀数组post[i]记录位置i及其之后是否还有对应的垃圾
            post = [False] * (n + 1)
            for i in range(n - 1, -1, -1):
                post[i] = post[i + 1] or tp in garbage[i]
            cnt = garbage[0].count(tp)
            for i in range(n - 1):
                if post[i + 1]:
                    cnt += travel[i]
                    cnt += garbage[i + 1].count(tp)
                else:
                    break
            return cnt
        n = len(garbage)
        return check('G') + check('M') + check('P')
```
### 复杂度分析
设字符串数组长度为$n$，单个字符串最大长度为$m$，则有
- 时间复杂度$O(nm)$
- 空间复杂度$O(n)$
### 题目感想
看起来有点唬人，中规中矩的中等题
***
## [题目四：给定条件下构造矩阵]

### 解题思路
分别根据行列的先后关系构图，使用拓扑排序给出一个可行的顺序
- 拓扑排序
### 代码
```python3
class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        
        def check(cond): # 标准的拓扑排序模板
            # 建图
            dct = defaultdict(list)
            degree = defaultdict(int)
            for i, j in cond:
                dct[i].append(j)
                degree[j] += 1
            
            # 按照出度为0进行
            stack = [i for i in range(1, k + 1) if not degree[i]]
            ans = []
            while stack:
                ans.extend(stack)
                nex = []
                for i in stack:
                    for j in dct[i]:
                        degree[j] -= 1
                        if not degree[j]:
                            nex.append(j)
                stack = nex
            return ans
        
        # 行列构图确定顺序
        row = check(rowConditions)
        col = check(colConditions)
        # 不满足条件
        if len(row) != k or len(col) != k:
            return []
        # 确定每个数值放置的位置进行赋值
        row_ind = {row[i]: i for i in range(k)}
        col_ind = {col[i]: i for i in range(k)}
        res = [[0] * k for _ in range(k)]
        for i in range(1, k + 1):
            res[row_ind[i]][col_ind[i]] = i
        return res
```
### 复杂度分析
设矩阵的行列数为$k$，则有
- 时间复杂度$O(k)$
- 空间复杂度$O(k^2)$
### 题目感想
应该算困难中的简单题了
***
### 写在最后
谢谢阅读，继续努力

[题目一: 和有限的最长子序列]: https://leetcode.cn/contest/weekly-contest-308/problems/longest-subsequence-with-limited-sum/

[题目二：从字符串中移除星号]: https://leetcode.cn/contest/weekly-contest-308/problems/removing-stars-from-a-string/
[题目三：收集垃圾的最少总时间]: https://leetcode.cn/contest/weekly-contest-308/problems/minimum-amount-of-time-to-collect-garbage/
[题目四：给定条件下构造矩阵]: https://leetcode.cn/contest/weekly-contest-308/problems/build-a-matrix-with-conditions/

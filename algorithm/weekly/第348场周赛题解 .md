

***

# [【儿须成名酒须醉】第 348 场力扣周赛题解]

***

### 竞赛日记
苦海无边，回头是岸！

[【儿须成名酒须醉】第 348 场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-348/

***    
## [题目一: 最小化字符串长度]
[题目一: 最小化字符串长度]: https://leetcode.cn/contest/weekly-contest-348/problems/minimize-string-length/
【儿须成名酒须醉】Python3+字符串+脑筋急转弯
### 解题思路

- 字符串
- 脑筋急转弯
### 代码
```python3
class Solution:
    def minimizedStringLength(self, s: str) -> int:
        return len(set(s))
```
### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目二：半有序排列]

[题目二：半有序排列]: https://leetcode.cn/contest/weekly-contest-348/problems/semi-ordered-permutation/
【儿须成名酒须醉】Python3+模拟+贪心
### 解题思路
直接模拟，贪心移动到最前面和最后面。
- 模拟
- 贪心

### 代码
```python3
class Solution:
    def semiOrderedPermutation(self, nums: List[int]) -> int:
        n = len(nums)
        i = nums.index(1)
        ans = 0
        for j in range(i, 0, -1):
            nums[j], nums[j - 1] = nums[j - 1], nums[j]
            ans += 1
        i = nums.index(n)
        ans += n - i - 1
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：查询后矩阵的和]

[题目三：查询后矩阵的和]: https://leetcode.cn/contest/weekly-contest-348/problems/sum-of-matrix-after-queries/
【儿须成名酒须醉】Python3+脑筋急转弯+倒序模拟
### 解题思路
倒序思考，每一行每一列的值只跟最后一次修改到的行或者列有关，即后面同行或者同列的操作会进行覆盖，因此只考虑最后一次修改，倒序遍历对于当前行来说，如果还未被修改过，则增加的值为 $val*(n-col_cnt)$ ，即减去后面的列覆盖过的个数，遇到列同样类似处理。
- 脑筋急转弯
- 倒序模拟

### 代码
```python3
class Solution:
    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:
        row = [0] * n
        col = [0] * n
        ans = row_cnt = col_cnt = 0
        m = len(queries)
        for i in range(m - 1, -1, -1):
            tp, ind, val = queries[i]
            if tp == 0 and not row[ind]:
                row[ind] = 1
                ans += val * (n - col_cnt)
                row_cnt += 1
            elif tp == 1 and not col[ind]:
                col[ind] = 1
                ans += val * (n - row_cnt)
                col_cnt += 1
        return ans
```
### 复杂度分析
设查询长度为$m$，矩阵行数为$n$，则有
- 时间复杂度$O(m)$
- 空间复杂度$O(n)$

***
## [题目四：统计整数数目]

[题目四：统计整数数目]: https://leetcode.cn/contest/weekly-contest-348/problems/count-of-integers/
【儿须成名酒须醉】Python3+数位DP
### 解题思路
套用灵神数位DP经典板子，也可以改为迭代使用。
- 数位DP

### 代码
```python3
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:

        def check(s):
            @lru_cache(None)
            def dfs(i, is_limit, is_num, cnt):
                if i == m:
                    return 1 if is_num and min_sum <= cnt <= max_sum else 0
                res = 0
                if not is_num:
                    res += dfs(i + 1, False, False, cnt)
                low = 0 if is_num else 1
                high = int(s[i]) if is_limit else 9
                for x in range(low, high + 1):
                    if cnt + x <= max_sum:
                        res += dfs(i + 1, is_limit and high == x, True, cnt + x)
                return res % mod
            m = len(s)
            cur = dfs(0, True, False, 0)
            dfs.cache_clear()
            return cur

        mod = 10 ** 9 + 7
        num1 = str(int(num1) - 1)
        return (check(num2) - check(num1)) % mod
```

### 迭代
```python3
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        
        def check(s):
            n = len(s)
            dp = [[[[0] * (max_sum+1) for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]
            # 数位 数位和 是否受限 是否为数字
            for i in range(n, -1, -1):
                for is_limit in range(1, -1, -1):
                    for is_num in range(1, -1, -1):
                        for cnt in range(max_sum, -1, -1):
                            if i == n:
                                dp[i][is_limit][is_num][cnt] = 1 if is_num and min_sum <= cnt <= max_sum else 0
                                continue
                            res = 0
                            if not is_num:
                                res += dp[i + 1][0][0][0]
                            floor = 0 if is_num else 1
                            ceil = int(s[i]) if is_limit else 9
                            for x in range(floor, ceil + 1):
                                if cnt + x <= max_sum:
                                    res += dp[i + 1][int(is_limit and ceil == x)][1][cnt+x]
                                    res %= mod
                            dp[i][is_limit][is_num][cnt] = res % mod
                            
            return dp[0][1][0][0]


        mod = 10 ** 9 + 7
        num1 = str(int(num1) - 1)
        return (check(num2) - check(num1)) % mod
```

### 复杂度分析
设数字之和最大为$n$，字符串长度为$m$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$
***

### 写在最后
谢谢阅读，继续努力！
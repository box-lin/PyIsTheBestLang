# [【儿须成名酒须醉】第319场力扣周赛题解]
***

### 写在前面
动态规划！动态规划！边界！转移！条件！明明都是老套的题目类型，为什么还是会卡顿！！
![image.png](https://pic.leetcode.cn/1668310410-zYWmav-image.png)

[【儿须成名酒须醉】第319场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-319/
***    
## [题目一: 温度转换]
[题目一: 温度转换]: https://leetcode.cn/contest/weekly-contest-319/problems/convert-the-temperature/

### 解题思路
史上最简单的T1了怕是
- 模拟
### 代码
```python3
class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius+273.15, celsius*1.80+32.00]
```
### 复杂度分析
输入只有一个浮点数，有
- 时间复杂度$O(1)$
- 空间复杂度$O(1)$
***
## [题目二：最小公倍数为 K 的子数组数目]

[题目二：最小公倍数为 K 的子数组数目]: https://leetcode.cn/contest/weekly-contest-319/problems/number-of-subarrays-with-lcm-equal-to-k/
### 解题思路
之前周赛出现过类似的题目，读题读全，要看好提示的数据范围，暴力计算即可
- 数学
- 暴力
### 代码
```python3
class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            x = 1
            for j in range(i, n):
                x = math.lcm(x, nums[j])
                if x == k:
                    ans += 1
                elif x > k:  # 剪枝
                    break
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n^{2}logn)$
- 空间复杂度$O(1)$


***
## [题目三：逐层排序二叉树所需的最少操作数目]

[题目三：逐层排序二叉树所需的最少操作数目]: https://leetcode.cn/contest/weekly-contest-319/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/
### 解题思路
注意题意只是交换节点的值，不交换节点，则子节点不受影响，因此使用层序遍历进行节点值获取，排序后使用并查集贪心计算每层需要的最少的交换次数，交换次数的计算有相似题目[765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/)
- 层序遍历
- 排序
- 并查集
- 贪心

### 代码
```python3
class UnionFind:
    # 标准并查集
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.size = [1] * n
        self.part = n

    def find(self, x):
        if x != self.root[x]:
            # 在查询的时候合并到顺带直接根节点
            root_x = self.find(self.root[x])
            self.root[x] = root_x
            return root_x
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        if self.size[root_x] >= self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        # 将非根节点的秩赋0
        self.size[root_x] = 0
        self.part -= 1
        return True


class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:

        def check(lst):
            val = [node.val for node in lst]
            tmp = sorted(val)
            # 使用哈希对取值进行编码
            ind = {num: i for i, num in enumerate(val)}
            n = len(val)
            uf = UnionFind(n)
            for i in range(n):
                uf.union(ind[val[i]], ind[tmp[i]])  
            # 计算最少交换次数
            return sum(p - 1 for p in uf.size if p >= 1)

        ans = 0
        stack = [root]
        # 层序遍历
        while stack:
            ans += check(stack)
            nex = []
            for node in stack:
                if node.left:
                    nex.append(node.left)
                if node.right:
                    nex.append(node.right)
            stack = nex[:]
        return ans
```
### 复杂度分析
设节点层数为$m$，每层节点最多个数为$n$，则有
- 时间复杂度$O(mnlogn)$
- 空间复杂度$O(n)$

***
## [题目四：不重叠回文子字符串的最大数目]

[题目四：不重叠回文子字符串的最大数目]: https://leetcode.cn/contest/weekly-contest-319/problems/maximum-number-of-non-overlapping-palindrome-substrings/
### 解题思路
常见的经典回文串动态规划题目，可以先使用动态规划或者马拉车算法计算连续子串是否为回文子串，然后再使用一层动态规划进行数目计算
- 动态规划
- 马拉车

计算$s[i:j+1]$是否为回文子串的公式为
$$res[i][j]=res[i+1][j-1]\  and\  s[i]==s[j]$$
计算$s[:i+1]$的不重叠回文子字符串的最大数目公式为
$$dp[i+1]=\max(dp[i], \max_{s[j:i+1]=s[j:i+1][::-1]}(dp[j]+1))$$

### 代码（4000+ms）
```python3
class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        res = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            res[i][i] = 1
            if i + 1 < n:
                res[i][i + 1] = 1 if s[i] == s[i + 1] else 0
            for j in range(i + 2, n): # i + 1 >= j - 1
                if s[i] == s[j] and res[i + 1][j - 1]:
                    res[i][j] = 1

        dp = [0] * (n + 1)
        for i in range(n):
            dp[i + 1] = dp[i]
            for j in range(0, i - k + 2):  # i - j + 1 >= k
                if i - j + 1 >= k and res[j][i]:
                    dp[i + 1] = max(dp[i + 1], dp[j] + 1)
        return dp[-1]
```

### 优化（1900+ms）
使用马拉车算法进行回文子串的判定优化！

```python3
def manacher(s):
    # 马拉车算法
    n = len(s)
    arm = [0] * n
    l, r = 0, -1
    for i in range(0, n):
        k = 1 if i > r else min(arm[l + r - i], r - i + 1)

        # 持续增加回文串的长度
        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
            k += 1
        arm[i] = k

        # 更新右侧最远的回文串边界
        k -= 1
        if i + k > r:
            l = i - k
            r = i + k
    # 返回每个位置往右的臂长
    return arm


def palindrome(s: str) -> int:
    # 获取区间的回文串信息
    n = len(s)
    t = "#" + "#".join(list(s)) + "#"
    dp = manacher(t)
    m = len(t)

    # 以当前索引作为边界结尾的回文子串起始位置索引
    res = [[] for _ in range(n)]
    for j in range(m):
        left = j - dp[j] + 1
        right = j + dp[j] - 1
        while left <= right:
            if t[left] != "#":
                res[right//2].append(left//2)
            left += 1
            right -= 1
    return res


class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        res = palindrome(s)
        dp = [0] * (n + 1)
        for i in range(n):
            dp[i + 1] = dp[i]
            # 只对以j为结尾的回文子串进行转移
            res[i].sort()
            for j in res[i]:
                if i - j + 1 >= k:
                    dp[i + 1] = max(dp[i + 1], dp[j] + 1)
                else:
                    break
        return dp[-1]
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n^{2})$
- 空间复杂度$O(n^{2})$
***

### 写在最后
谢谢阅读，继续努力！


***

# [【儿须成名酒须醉】第 343 场力扣周赛题解]

***

### 写在前面
掉分不过是一切从头再来，终有破晓之日！

[【儿须成名酒须醉】第 343 场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-343/
***    
## [题目一: 保龄球游戏的获胜者]
[题目一: 保龄球游戏的获胜者]: https://leetcode.cn/contest/weekly-contest-343/problems/determine-the-winner-of-a-bowling-game/

【儿须成名酒须醉】Python3+模拟
### 解题思路
不想多说，看看英文的原文吧。
- 模拟

### 代码
```python
class Solution:
    def isWinner(self, player1: List[int], player2: List[int]) -> int:

        def check(player):
            ans = 0
            n = len(player)
            for i in range(n):
                if (i >= 1 and player[i - 1] == 10) or (i >= 2 and player[i - 2] == 10):
                    ans += 2 * player[i]
                else:
                    ans += player[i]
            return ans

        ans1 = check(player1)
        ans2 = check(player2)
        if ans1 > ans2:
            return 1
        if ans1 < ans2:
            return 2
        return 0
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$

***

## [题目二：找出叠涂元素]

[题目二：找出叠涂元素]: https://leetcode.cn/contest/weekly-contest-343/problems/first-completely-painted-row-or-column/

【儿须成名酒须醉】Python3+模拟+哈希
### 解题思路
遍历矩阵，记录数字对应的索引，然后使用一个行数组和列数组记录染色次数。
- 模拟
- 哈希
### 代码
```python
class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:

        m, n = len(mat), len(mat[0])
        ind = {}
        for i in range(m):
            for j in range(n):
                ind[mat[i][j]] = [i, j]

        row = [0] * m
        col = [0] * n
        for x, num in enumerate(arr):
            i, j = ind[num]
            row[i] += 1
            col[j] += 1
            if row[i] == n or col[j] == m:
                return x
        return -1
```
### 复杂度分析
设矩阵行列数为$m$和$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$


***
## [题目三：前往目标的最小代价]

[题目三：前往目标的最小代价]: https://leetcode.cn/contest/weekly-contest-343/problems/minimum-cost-of-a-path-with-special-roads/
【儿须成名酒须醉】Python3+模拟+Dijkstra
### 解题思路
没有明说的最重要的两点，有重边，且特殊路径是单向的。
- 模拟
- Dijkstra
### 代码
```python
class Solution:
    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        lst = [start, target]
        
        def min(v1, v2):
            return v1 if v1 < v2 else v2
        
        dct = defaultdict(lambda: defaultdict(lambda: inf))
        for x1, y1, x2, y2, cost in specialRoads:
            dct[(x1, y1)][(x2, y2)] = min(dct[(x1, y1)][(x2, y2)], cost)
            lst.append([x1, y1])
            lst.append([x2, y2])
            
        m = len(lst)
        for i in range(m):
            for j in range(i+1, m):
                x1, y1 = lst[i]
                x2, y2 = lst[j]
                dct[(x1, y1)][(x2, y2)] = min(dct[(x1, y1)][(x2, y2)], abs(y1 - y2) + abs(x1 - x2))
                dct[(x2, y2)][(x1, y1)] = min(dct[(x2, y2)][(x1, y1)], abs(y1 - y2) + abs(x1 - x2))

        a, b = start
        c, d = target
        visit = defaultdict(lambda: inf)
        stack = [[0, a, b]]
        visit[(a, b)] = 0

        while stack:
            dd, i, j = heapq.heappop(stack)
            if visit[(i, j)] < dd:
                continue
            visit[(i, j)] = dd
            for x, y in dct[(i, j)]:
                dj = dct[(i, j)][(x, y)] + dd
                if dj < visit[(x, y)]:
                    visit[(x, y)] = dj
                    heapq.heappush(stack, [dj, x, y])
        c, d = target
        return visit[(c, d)]
```
### 复杂度分析
设特殊路径数为$n$，则有
- 时间复杂度$O(n^2logn)$
- 空间复杂度$O(n^2)$

***
## [题目四：字典序最小的美丽字符串]

[题目四：字典序最小的美丽字符串]: https://leetcode.cn/contest/weekly-contest-343/problems/lexicographically-smallest-beautiful-string/
【儿须成名酒须醉】Python3+模拟+贪心
### 解题思路
要求字典序更大，且最小，因此从后往前遍历，确定第一个修改的字母位置，取前面剩余的加这个位置修改的作为前缀，然后依次贪心往后加最小的字典序字母，由于回文子串的特点，只需保持验证结果里面后缀长度为2和长度为3的不是回文即可。
- 模拟
- 贪心

### 代码
```python
class Solution:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        n = len(s)
        for i in range(n - 1, -1, -1):
            for x in range(ord(s[i]) - ord("a") + 1, k):
                w = chr(ord("a") + x)
                if (i == 0 or s[i - 1] != w) and not (i >= 2 and w == s[i - 2]):
                    ans = s[:i] + w
                    while len(ans) < n:
                        for y in range(0, k):
                            x = chr(y + ord("a"))
                            if x != ans[-1] and (len(ans) < 2 or ans[-2] != x):
                                ans += x
                                break
                    return ans
        return ""
```


### 复杂度分析
设字符串长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***

### 写在最后
谢谢阅读，继续努力，如有错漏，敬请指正！
***

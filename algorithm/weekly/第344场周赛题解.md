

***

# [【儿须成名酒须醉】第 344 场力扣周赛题解]

***

### 竞赛日记
> 第 342 场周赛，掉分！
> 第 343 场周赛，又掉分！
> 第 344 场周赛，还是掉分！

[【儿须成名酒须醉】第 344 场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-344/
***    
## [题目一: 找出不同元素数目差数组]
[题目一: 找出不同元素数目差数组]: https://leetcode.cn/contest/weekly-contest-344/problems/find-the-distinct-difference-array/

【儿须成名酒须醉】Python3+模拟+前后缀集合计数
### 解题思路
预处理计算前后缀集合元素个数即可，数据小也可以直接暴力。
- 模拟
- 前后缀集合计数

### 代码
```python
class Solution:
    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        
        pre = [0]*n
        dct = set()
        for i in range(n):
            dct.add(nums[i])
            pre[i] = len(dct)
            
        post = [0]*(n+1)
        dct = set()
        for i in range(n-1, -1, -1):
            dct.add(nums[i])
            post[i] = len(dct)
            
        return [pre[i]-post[i+1] for i in range(n)]
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***

## [题目二：频率跟踪器]

[题目二：频率跟踪器]: https://leetcode.cn/contest/weekly-contest-344/problems/frequency-tracker/

【儿须成名酒须醉】Python3+模拟+哈希
### 解题思路
使用一个哈希记录次数，一个哈希记录次数的次数，进行动态维护。
- 模拟
- 哈希
### 代码
```python
class FrequencyTracker:

    def __init__(self):
        self.dct = defaultdict(int)
        self.cnt = defaultdict(int)

    def add(self, number: int) -> None:
        self.dct[number] += 1
        self.cnt[self.dct[number]] += 1
        self.cnt[self.dct[number] - 1] -= 1
        return 
    
    def deleteOne(self, number: int) -> None:
        if self.dct[number] > 0:
            self.dct[number] -= 1
            self.cnt[self.dct[number]] += 1
            self.cnt[self.dct[number] + 1] -= 1
        return 

    def hasFrequency(self, frequency: int) -> bool:
        return self.cnt[frequency] > 0
```
### 复杂度分析
设操作调用次数为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：有相同颜色的相邻元素数目]

[题目三：有相同颜色的相邻元素数目]: https://leetcode.cn/contest/weekly-contest-344/problems/number-of-adjacent-elements-with-the-same-color/
【儿须成名酒须醉】Python3+模拟
### 解题思路
同第二题的思路，使用变量维护相邻对颜色相同的数目
- 模拟

### 代码
```python
class Solution:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        nums = [0] * n
        ans = 0
        res = []
        for ind, c in queries:
            for i in [ind - 1, ind + 1]:
                if 0 <= i < n and nums[ind] == nums[i] > 0:
                    ans -= 1
            nums[ind] = c
            for i in [ind - 1, ind + 1]:
                if 0 <= i < n and nums[ind] == nums[i] > 0:
                    ans += 1
            res.append(ans)
        return res
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***
## [题目四：使二叉树所有路径值相等的最小代价]

[题目四：使二叉树所有路径值相等的最小代价]: https://leetcode.cn/contest/weekly-contest-344/problems/make-costs-of-paths-equal-in-a-binary-tree/
【儿须成名酒须醉】Python3+贪心+深度优先搜索
### 解题思路
1. 首先一遍DFS计算到达每个叶子结点的最大路径和，选取这个作为最终相等的路径值显然代价最小，并记录每个子树最大的路径和;
2. 再来一遍DFS，访问到一个节点时，如果子树最大路径和小于最终值，则在此节点贪心增加这个差值，最大化增加值给其余节点带来的贡献。

- 贪心
- 深度优先搜索

### 代码
```python
class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        sub = [0] * n
        # 使用迭代写法实现深搜DFS
        stack = [[0, 0]]
        while stack:
            i, pre_sum = stack.pop()
            if i >= 0:
                # 自顶向下
                stack.append([~i, pre_sum])
                pre_sum += cost[i]
                sub[i] = pre_sum
                for j in [2 * i + 1, 2 * i + 2]:
                    if j < n:
                        stack.append([j, pre_sum])
            else:
                # 自底向上
                i = ~i
                for j in [2 * i + 1, 2 * i + 2]:
                    if j < n:
                        sub[i] = sub[i] if sub[i] > sub[j] else sub[j]

        ceil = max(sub)  # 最大路径和
        stack = [[0, 0, 0]]
        ans = 0
        while stack:
            # 当前节点 前序路径和 前序操作次数
            i, pre_sum, pre_add = stack.pop()
            pre_sum += cost[i]
            if sub[i] + pre_add < ceil:
                # 还有多余的操作空间
                x = ceil - sub[i] - pre_add
                ans += x
                pre_add += x
                pre_sum += x
            for j in [2 * i + 1, 2 * i + 2]:
                if j < n:
                    stack.append([j, pre_sum, pre_add])
        return ans
```


### 复杂度分析
设树节点个数为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$
***

### 写在最后
谢谢阅读，继续努力，如有错漏，敬请指正！
***



![Cow2](https://github.com/liupengsay/PCRecord/blob/main/algorithm/picture/title_liupengsay.png?raw=true)
***

# [【儿须成名酒须醉】😺 第 103 场力扣夜喵双周赛题解]

***

### 写在前面
掉分不过是一切从头再来，终有破晓之日！

[【儿须成名酒须醉】😺 第 103 场力扣夜喵双周赛题解]: https://leetcode.cn/contest/biweekly-contest-92/
***    
## [题目一: K 个元素的最大和]
[题目一: K 个元素的最大和]: https://leetcode.cn/contest/biweekly-contest-103/problems/maximum-sum-with-exactly-k-elements/
【儿须成名酒须醉】Python3+模拟+脑筋急转弯
### 解题思路
根据题意直接拿最大值操作一直都是最大值，直接使用等差数列求和公式即可。
- 模拟
- 脑筋急转弯
### 代码
```python
class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        num = max(nums)
        ans = k * (num + k - 1 + num) // 2
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(1)$

***

## [题目二：找到两个数组的前缀公共数组]

[题目二：找到两个数组的前缀公共数组]: https://leetcode.cn/contest/biweekly-contest-103/problems/find-the-prefix-common-array-of-two-arrays/
【儿须成名酒须醉】Python3+模拟+集合
### 解题思路
遍历数组，分别用两个set记录各自数组前缀值，再用一个set记录交集，由于是排列，也可以直接使用数组。
- 模拟
- 集合
### 代码
```python
class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        n = len(A)
        ans = []
        pre_b = set()
        pre_a = set()
        inter = set()
        for i in range(n):
            pre_b.add(B[i])
            pre_a.add(A[i])
            if A[i] in pre_b:
                inter.add(A[i])
            if B[i] in pre_a:
                inter.add(B[i])
            ans.append(len(inter))
        return ans
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：网格图中鱼的最大数目]

[题目三：网格图中鱼的最大数目]: https://leetcode.cn/contest/biweekly-contest-103/problems/maximum-number-of-fish-in-a-grid/
【儿须成名酒须醉】Python3+模拟+广度优先搜索
### 解题思路
不明白为什么是hard标签，题库随便几个岛屿题都比这有意思，还差点理解为水域不能重复经过。
- 模拟
- 广度优先搜索
### 代码
```python
class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] > 0:
                    stack = [[i, j]]
                    cur = grid[i][j]
                    grid[i][j] = 0
                    while stack:
                        a, b = stack.pop()
                        for x, y in [[a + 1, b], [a, b + 1],[a, b - 1], [a - 1, b]]:
                            if 0 <= x < m and 0 <= y < n and grid[x][y] > 0:
                                stack.append([x, y])
                                cur += grid[x][y]
                                grid[x][y] = 0
                    ans = ans if ans > cur else cur
        return ans
```
### 复杂度分析
设网格的行数与列数分别为$m$和$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(1)$

***
## [题目四：将数组清空]

[题目四：将数组清空]: https://leetcode.cn/contest/biweekly-contest-103/problems/make-array-empty/
【儿须成名酒须醉】Python3+模拟+有序列表
### 解题思路
按照题意，进行模拟删除，由于是不同数字，可以离散化为索引，使用SortedList维护还未移除的索引，以及当前数组开头的索引的索引位置。
- 模拟
- 有序列表

### 代码
```python
from sortedcontainers import SortedList


class Solution:
    def countOperationsToEmptyArray(self, nums: List[int]) -> int:
        n = len(nums)
        lst = SortedList(range(n))
        ind = {num: i for i, num in enumerate(nums)}
        ans = n

        # 当前数组开头的索引对应在有序列表中的索引
        start = 0  
        for num in sorted(nums):

            # 当前需要移除的数字对应的索引
            i = ind[num]  
            j = lst.bisect_left(i)

            # 就在当前开头的索引后面
            if start <= j:
                ans += j - start
            else:
                # 在当前开头的索引前面
                ans += len(lst) - (start - j)

            # 新的开头注意结尾到头
            start = j
            if start == len(lst):
                start = 0
            lst.pop(j)
        return ans
```


### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(nlogn)$
- 空间复杂度$O(n)$
***

### 写在最后
谢谢阅读，继续努力，如有错漏，敬请指正！
***



***

# [【儿须成名酒须醉】第 345 场力扣周赛题解]

***

### 竞赛日记
> 第 342 场周赛，掉分！
> 第 343 场周赛，又掉分！
> 第 344 场周赛，还是掉分！
> 第 345 场周赛，终于上分了

[【儿须成名酒须醉】第 345 场力扣周赛题解]: https://leetcode.cn/contest/weekly-contest-345/
***    
## [题目一: 找出转圈游戏输家]
[题目一: 找出转圈游戏输家]: https://leetcode.cn/contest/weekly-contest-345/problems/find-the-losers-of-the-circular-game/

【儿须成名酒须醉】Python3+模拟
### 解题思路
按照题意进行模拟，使用集合记录已经出现过的元素。
- 模拟
- 集合

### 代码
```python
class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        pre = set()
        x = 0
        r = 1
        while x not in pre:
            pre.add(x)
            x += r * k
            x %= n
            r += 1
        return [i + 1 for i in range(n) if i not in pre]
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$

***

## [题目二：相邻值的按位异或]

[题目二：相邻值的按位异或]: https://leetcode.cn/contest/weekly-contest-345/problems/neighboring-bitwise-xor/

【儿须成名酒须醉】Python3+枚举+异或
### 解题思路
由于是二进制数组，利用异或特性有$original[i] = original[i + 1]\ xor\  derived[i]$，枚举$original[n-1]$分别为0和1时的情形。
- 枚举
- 异或
### 代码
```python
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        n = len(derived)
        for x in [0, 1]:
            original = [0] * n
            original[-1] = x
            for i in range(n - 2, -1, -1):
                original[i] = original[i + 1] ^ derived[i]
            if original[n - 1] ^ original[0] == derived[n - 1]:
                return True
        return False
```
### 复杂度分析
设数组长度为$n$，则有
- 时间复杂度$O(n)$
- 空间复杂度$O(n)$


***
## [题目三：矩阵中移动的最大次数]

[题目三：矩阵中移动的最大次数]: https://leetcode.cn/contest/weekly-contest-345/problems/maximum-number-of-moves-in-a-grid/
【儿须成名酒须醉】Python3+动态规划+记忆化搜索
### 解题思路
经典的动态规划，采用记忆化搜索，注意只能从第一列出发，只能往三个方向转移。
- 动态规划
- 记忆化搜索

### 代码（记忆）
```python
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:

        @lru_cache(None)
        def dfs(i, j):
            res = 0
            for x, y in [[i - 1, j + 1], [i, j + 1], [i + 1, j + 1]]:
                if 0 <= x < m and 0 <= y < n and grid[x][y] > grid[i][j]:
                    res = max(res, 1 + dfs(x, y))
            return res

        m, n = len(grid), len(grid[0])
        return max(dfs(i, 0) for i in range(m))
```

### 代码（迭代）

```python
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0]*n for _ in range(m)]
        for j in range(n - 1, -1, -1):
            for i in range(m):
                res = 0
                for x, y in [[i - 1, j + 1], [i, j + 1], [i + 1, j + 1]]:
                    if 0 <= x < m and 0 <= y < n and grid[x][y] > grid[i][j]:
                        res = max(res, 1 + dp[x][y])
                dp[i][j] = res
        return max(dp[i][0] for i in range(m))
```

### 复杂度分析
设矩阵行数为$m$，列数为$n$，则有
- 时间复杂度$O(mn)$
- 空间复杂度$O(mn)$

***
## [题目四：统计完全连通分量的数量]

[题目四：统计完全连通分量的数量]: https://leetcode.cn/contest/weekly-contest-345/problems/count-the-number-of-complete-components/
【儿须成名酒须醉】Python3+并查集+枚举
### 解题思路
1. 首先使用并查集计算所有的连通块与对应的节点。
2. 再校验每个连通块内部两两之间是否存在边。
- 并查集
- 枚举

### 代码
```python
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UnionFind(n)
        dct = [set() for _ in range(n)]
        for i, j in edges:
            uf.union(i, j)
            dct[i].add(j)
            dct[j].add(i)
            
        part = uf.get_root_part()
        ans = 0
        for p in part:
            nodes = set(part[p])
            res = True
            for x in nodes:
                if all(y in dct[x] for y in nodes if y != x):
                    continue
                else:
                    res = False
                    break
            if res:
                ans += 1
        return ans
```


### 复杂度分析
设节点个数为$n$，边条数为$m$，则有
- 时间复杂度$O(\alpha(n)+m)$
- 空间复杂度$O(n+m)$
***

### 写在最后
谢谢阅读，继续努力，如有错漏，敬请指正！
***
